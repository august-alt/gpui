// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "policydefinitions.h"

namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
    // DecimalElement
    // 

    const DecimalElement::IdType& DecimalElement::
    id () const
    {
      return this->id_.get ();
    }

    DecimalElement::IdType& DecimalElement::
    id ()
    {
      return this->id_.get ();
    }

    void DecimalElement::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void DecimalElement::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const DecimalElement::ClientExtensionOptional& DecimalElement::
    clientExtension () const
    {
      return this->clientExtension_;
    }

    DecimalElement::ClientExtensionOptional& DecimalElement::
    clientExtension ()
    {
      return this->clientExtension_;
    }

    void DecimalElement::
    clientExtension (const ClientExtensionType& x)
    {
      this->clientExtension_.set (x);
    }

    void DecimalElement::
    clientExtension (const ClientExtensionOptional& x)
    {
      this->clientExtension_ = x;
    }

    void DecimalElement::
    clientExtension (::std::unique_ptr< ClientExtensionType > x)
    {
      this->clientExtension_.set (std::move (x));
    }

    const DecimalElement::KeyOptional& DecimalElement::
    key () const
    {
      return this->key_;
    }

    DecimalElement::KeyOptional& DecimalElement::
    key ()
    {
      return this->key_;
    }

    void DecimalElement::
    key (const KeyType& x)
    {
      this->key_.set (x);
    }

    void DecimalElement::
    key (const KeyOptional& x)
    {
      this->key_ = x;
    }

    void DecimalElement::
    key (::std::unique_ptr< KeyType > x)
    {
      this->key_.set (std::move (x));
    }

    const DecimalElement::ValueNameOptional& DecimalElement::
    valueName () const
    {
      return this->valueName_;
    }

    DecimalElement::ValueNameOptional& DecimalElement::
    valueName ()
    {
      return this->valueName_;
    }

    void DecimalElement::
    valueName (const ValueNameType& x)
    {
      this->valueName_.set (x);
    }

    void DecimalElement::
    valueName (const ValueNameOptional& x)
    {
      this->valueName_ = x;
    }

    void DecimalElement::
    valueName (::std::unique_ptr< ValueNameType > x)
    {
      this->valueName_.set (std::move (x));
    }

    const DecimalElement::RequiredType& DecimalElement::
    required () const
    {
      return this->required_.get ();
    }

    DecimalElement::RequiredType& DecimalElement::
    required ()
    {
      return this->required_.get ();
    }

    void DecimalElement::
    required (const RequiredType& x)
    {
      this->required_.set (x);
    }

    DecimalElement::RequiredType DecimalElement::
    required_default_value ()
    {
      return RequiredType (false);
    }

    const DecimalElement::MinValueType& DecimalElement::
    minValue () const
    {
      return this->minValue_.get ();
    }

    DecimalElement::MinValueType& DecimalElement::
    minValue ()
    {
      return this->minValue_.get ();
    }

    void DecimalElement::
    minValue (const MinValueType& x)
    {
      this->minValue_.set (x);
    }

    DecimalElement::MinValueType DecimalElement::
    minValue_default_value ()
    {
      return MinValueType (0U);
    }

    const DecimalElement::MaxValueType& DecimalElement::
    maxValue () const
    {
      return this->maxValue_.get ();
    }

    DecimalElement::MaxValueType& DecimalElement::
    maxValue ()
    {
      return this->maxValue_.get ();
    }

    void DecimalElement::
    maxValue (const MaxValueType& x)
    {
      this->maxValue_.set (x);
    }

    DecimalElement::MaxValueType DecimalElement::
    maxValue_default_value ()
    {
      return MaxValueType (9999U);
    }

    const DecimalElement::StoreAsTextType& DecimalElement::
    storeAsText () const
    {
      return this->storeAsText_.get ();
    }

    DecimalElement::StoreAsTextType& DecimalElement::
    storeAsText ()
    {
      return this->storeAsText_.get ();
    }

    void DecimalElement::
    storeAsText (const StoreAsTextType& x)
    {
      this->storeAsText_.set (x);
    }

    DecimalElement::StoreAsTextType DecimalElement::
    storeAsText_default_value ()
    {
      return StoreAsTextType (false);
    }

    const DecimalElement::SoftType& DecimalElement::
    soft () const
    {
      return this->soft_.get ();
    }

    DecimalElement::SoftType& DecimalElement::
    soft ()
    {
      return this->soft_.get ();
    }

    void DecimalElement::
    soft (const SoftType& x)
    {
      this->soft_.set (x);
    }

    DecimalElement::SoftType DecimalElement::
    soft_default_value ()
    {
      return SoftType (false);
    }


    // LongDecimalElement
    // 

    const LongDecimalElement::IdType& LongDecimalElement::
    id () const
    {
      return this->id_.get ();
    }

    LongDecimalElement::IdType& LongDecimalElement::
    id ()
    {
      return this->id_.get ();
    }

    void LongDecimalElement::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void LongDecimalElement::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const LongDecimalElement::ClientExtensionOptional& LongDecimalElement::
    clientExtension () const
    {
      return this->clientExtension_;
    }

    LongDecimalElement::ClientExtensionOptional& LongDecimalElement::
    clientExtension ()
    {
      return this->clientExtension_;
    }

    void LongDecimalElement::
    clientExtension (const ClientExtensionType& x)
    {
      this->clientExtension_.set (x);
    }

    void LongDecimalElement::
    clientExtension (const ClientExtensionOptional& x)
    {
      this->clientExtension_ = x;
    }

    void LongDecimalElement::
    clientExtension (::std::unique_ptr< ClientExtensionType > x)
    {
      this->clientExtension_.set (std::move (x));
    }

    const LongDecimalElement::KeyOptional& LongDecimalElement::
    key () const
    {
      return this->key_;
    }

    LongDecimalElement::KeyOptional& LongDecimalElement::
    key ()
    {
      return this->key_;
    }

    void LongDecimalElement::
    key (const KeyType& x)
    {
      this->key_.set (x);
    }

    void LongDecimalElement::
    key (const KeyOptional& x)
    {
      this->key_ = x;
    }

    void LongDecimalElement::
    key (::std::unique_ptr< KeyType > x)
    {
      this->key_.set (std::move (x));
    }

    const LongDecimalElement::ValueNameOptional& LongDecimalElement::
    valueName () const
    {
      return this->valueName_;
    }

    LongDecimalElement::ValueNameOptional& LongDecimalElement::
    valueName ()
    {
      return this->valueName_;
    }

    void LongDecimalElement::
    valueName (const ValueNameType& x)
    {
      this->valueName_.set (x);
    }

    void LongDecimalElement::
    valueName (const ValueNameOptional& x)
    {
      this->valueName_ = x;
    }

    void LongDecimalElement::
    valueName (::std::unique_ptr< ValueNameType > x)
    {
      this->valueName_.set (std::move (x));
    }

    const LongDecimalElement::RequiredType& LongDecimalElement::
    required () const
    {
      return this->required_.get ();
    }

    LongDecimalElement::RequiredType& LongDecimalElement::
    required ()
    {
      return this->required_.get ();
    }

    void LongDecimalElement::
    required (const RequiredType& x)
    {
      this->required_.set (x);
    }

    LongDecimalElement::RequiredType LongDecimalElement::
    required_default_value ()
    {
      return RequiredType (false);
    }

    const LongDecimalElement::MinValueType& LongDecimalElement::
    minValue () const
    {
      return this->minValue_.get ();
    }

    LongDecimalElement::MinValueType& LongDecimalElement::
    minValue ()
    {
      return this->minValue_.get ();
    }

    void LongDecimalElement::
    minValue (const MinValueType& x)
    {
      this->minValue_.set (x);
    }

    LongDecimalElement::MinValueType LongDecimalElement::
    minValue_default_value ()
    {
      return MinValueType (0ULL);
    }

    const LongDecimalElement::MaxValueType& LongDecimalElement::
    maxValue () const
    {
      return this->maxValue_.get ();
    }

    LongDecimalElement::MaxValueType& LongDecimalElement::
    maxValue ()
    {
      return this->maxValue_.get ();
    }

    void LongDecimalElement::
    maxValue (const MaxValueType& x)
    {
      this->maxValue_.set (x);
    }

    LongDecimalElement::MaxValueType LongDecimalElement::
    maxValue_default_value ()
    {
      return MaxValueType (9999ULL);
    }

    const LongDecimalElement::StoreAsTextType& LongDecimalElement::
    storeAsText () const
    {
      return this->storeAsText_.get ();
    }

    LongDecimalElement::StoreAsTextType& LongDecimalElement::
    storeAsText ()
    {
      return this->storeAsText_.get ();
    }

    void LongDecimalElement::
    storeAsText (const StoreAsTextType& x)
    {
      this->storeAsText_.set (x);
    }

    LongDecimalElement::StoreAsTextType LongDecimalElement::
    storeAsText_default_value ()
    {
      return StoreAsTextType (false);
    }

    const LongDecimalElement::SoftType& LongDecimalElement::
    soft () const
    {
      return this->soft_.get ();
    }

    LongDecimalElement::SoftType& LongDecimalElement::
    soft ()
    {
      return this->soft_.get ();
    }

    void LongDecimalElement::
    soft (const SoftType& x)
    {
      this->soft_.set (x);
    }

    LongDecimalElement::SoftType LongDecimalElement::
    soft_default_value ()
    {
      return SoftType (false);
    }


    // BooleanElement
    // 

    const BooleanElement::TrueValueOptional& BooleanElement::
    trueValue () const
    {
      return this->trueValue_;
    }

    BooleanElement::TrueValueOptional& BooleanElement::
    trueValue ()
    {
      return this->trueValue_;
    }

    void BooleanElement::
    trueValue (const TrueValueType& x)
    {
      this->trueValue_.set (x);
    }

    void BooleanElement::
    trueValue (const TrueValueOptional& x)
    {
      this->trueValue_ = x;
    }

    void BooleanElement::
    trueValue (::std::unique_ptr< TrueValueType > x)
    {
      this->trueValue_.set (std::move (x));
    }

    const BooleanElement::FalseValueOptional& BooleanElement::
    falseValue () const
    {
      return this->falseValue_;
    }

    BooleanElement::FalseValueOptional& BooleanElement::
    falseValue ()
    {
      return this->falseValue_;
    }

    void BooleanElement::
    falseValue (const FalseValueType& x)
    {
      this->falseValue_.set (x);
    }

    void BooleanElement::
    falseValue (const FalseValueOptional& x)
    {
      this->falseValue_ = x;
    }

    void BooleanElement::
    falseValue (::std::unique_ptr< FalseValueType > x)
    {
      this->falseValue_.set (std::move (x));
    }

    const BooleanElement::TrueListOptional& BooleanElement::
    trueList () const
    {
      return this->trueList_;
    }

    BooleanElement::TrueListOptional& BooleanElement::
    trueList ()
    {
      return this->trueList_;
    }

    void BooleanElement::
    trueList (const TrueListType& x)
    {
      this->trueList_.set (x);
    }

    void BooleanElement::
    trueList (const TrueListOptional& x)
    {
      this->trueList_ = x;
    }

    void BooleanElement::
    trueList (::std::unique_ptr< TrueListType > x)
    {
      this->trueList_.set (std::move (x));
    }

    const BooleanElement::FalseListOptional& BooleanElement::
    falseList () const
    {
      return this->falseList_;
    }

    BooleanElement::FalseListOptional& BooleanElement::
    falseList ()
    {
      return this->falseList_;
    }

    void BooleanElement::
    falseList (const FalseListType& x)
    {
      this->falseList_.set (x);
    }

    void BooleanElement::
    falseList (const FalseListOptional& x)
    {
      this->falseList_ = x;
    }

    void BooleanElement::
    falseList (::std::unique_ptr< FalseListType > x)
    {
      this->falseList_.set (std::move (x));
    }

    const BooleanElement::IdType& BooleanElement::
    id () const
    {
      return this->id_.get ();
    }

    BooleanElement::IdType& BooleanElement::
    id ()
    {
      return this->id_.get ();
    }

    void BooleanElement::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void BooleanElement::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const BooleanElement::ClientExtensionOptional& BooleanElement::
    clientExtension () const
    {
      return this->clientExtension_;
    }

    BooleanElement::ClientExtensionOptional& BooleanElement::
    clientExtension ()
    {
      return this->clientExtension_;
    }

    void BooleanElement::
    clientExtension (const ClientExtensionType& x)
    {
      this->clientExtension_.set (x);
    }

    void BooleanElement::
    clientExtension (const ClientExtensionOptional& x)
    {
      this->clientExtension_ = x;
    }

    void BooleanElement::
    clientExtension (::std::unique_ptr< ClientExtensionType > x)
    {
      this->clientExtension_.set (std::move (x));
    }

    const BooleanElement::KeyOptional& BooleanElement::
    key () const
    {
      return this->key_;
    }

    BooleanElement::KeyOptional& BooleanElement::
    key ()
    {
      return this->key_;
    }

    void BooleanElement::
    key (const KeyType& x)
    {
      this->key_.set (x);
    }

    void BooleanElement::
    key (const KeyOptional& x)
    {
      this->key_ = x;
    }

    void BooleanElement::
    key (::std::unique_ptr< KeyType > x)
    {
      this->key_.set (std::move (x));
    }

    const BooleanElement::ValueNameOptional& BooleanElement::
    valueName () const
    {
      return this->valueName_;
    }

    BooleanElement::ValueNameOptional& BooleanElement::
    valueName ()
    {
      return this->valueName_;
    }

    void BooleanElement::
    valueName (const ValueNameType& x)
    {
      this->valueName_.set (x);
    }

    void BooleanElement::
    valueName (const ValueNameOptional& x)
    {
      this->valueName_ = x;
    }

    void BooleanElement::
    valueName (::std::unique_ptr< ValueNameType > x)
    {
      this->valueName_.set (std::move (x));
    }


    // TextElement
    // 

    const TextElement::IdType& TextElement::
    id () const
    {
      return this->id_.get ();
    }

    TextElement::IdType& TextElement::
    id ()
    {
      return this->id_.get ();
    }

    void TextElement::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void TextElement::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const TextElement::ClientExtensionOptional& TextElement::
    clientExtension () const
    {
      return this->clientExtension_;
    }

    TextElement::ClientExtensionOptional& TextElement::
    clientExtension ()
    {
      return this->clientExtension_;
    }

    void TextElement::
    clientExtension (const ClientExtensionType& x)
    {
      this->clientExtension_.set (x);
    }

    void TextElement::
    clientExtension (const ClientExtensionOptional& x)
    {
      this->clientExtension_ = x;
    }

    void TextElement::
    clientExtension (::std::unique_ptr< ClientExtensionType > x)
    {
      this->clientExtension_.set (std::move (x));
    }

    const TextElement::KeyOptional& TextElement::
    key () const
    {
      return this->key_;
    }

    TextElement::KeyOptional& TextElement::
    key ()
    {
      return this->key_;
    }

    void TextElement::
    key (const KeyType& x)
    {
      this->key_.set (x);
    }

    void TextElement::
    key (const KeyOptional& x)
    {
      this->key_ = x;
    }

    void TextElement::
    key (::std::unique_ptr< KeyType > x)
    {
      this->key_.set (std::move (x));
    }

    const TextElement::ValueNameOptional& TextElement::
    valueName () const
    {
      return this->valueName_;
    }

    TextElement::ValueNameOptional& TextElement::
    valueName ()
    {
      return this->valueName_;
    }

    void TextElement::
    valueName (const ValueNameType& x)
    {
      this->valueName_.set (x);
    }

    void TextElement::
    valueName (const ValueNameOptional& x)
    {
      this->valueName_ = x;
    }

    void TextElement::
    valueName (::std::unique_ptr< ValueNameType > x)
    {
      this->valueName_.set (std::move (x));
    }

    const TextElement::RequiredType& TextElement::
    required () const
    {
      return this->required_.get ();
    }

    TextElement::RequiredType& TextElement::
    required ()
    {
      return this->required_.get ();
    }

    void TextElement::
    required (const RequiredType& x)
    {
      this->required_.set (x);
    }

    TextElement::RequiredType TextElement::
    required_default_value ()
    {
      return RequiredType (false);
    }

    const TextElement::MaxLengthType& TextElement::
    maxLength () const
    {
      return this->maxLength_.get ();
    }

    TextElement::MaxLengthType& TextElement::
    maxLength ()
    {
      return this->maxLength_.get ();
    }

    void TextElement::
    maxLength (const MaxLengthType& x)
    {
      this->maxLength_.set (x);
    }

    TextElement::MaxLengthType TextElement::
    maxLength_default_value ()
    {
      return MaxLengthType (1023U);
    }

    const TextElement::ExpandableType& TextElement::
    expandable () const
    {
      return this->expandable_.get ();
    }

    TextElement::ExpandableType& TextElement::
    expandable ()
    {
      return this->expandable_.get ();
    }

    void TextElement::
    expandable (const ExpandableType& x)
    {
      this->expandable_.set (x);
    }

    TextElement::ExpandableType TextElement::
    expandable_default_value ()
    {
      return ExpandableType (false);
    }

    const TextElement::SoftType& TextElement::
    soft () const
    {
      return this->soft_.get ();
    }

    TextElement::SoftType& TextElement::
    soft ()
    {
      return this->soft_.get ();
    }

    void TextElement::
    soft (const SoftType& x)
    {
      this->soft_.set (x);
    }

    TextElement::SoftType TextElement::
    soft_default_value ()
    {
      return SoftType (false);
    }


    // EnumerationElement
    // 

    const EnumerationElement::ItemSequence& EnumerationElement::
    item () const
    {
      return this->item_;
    }

    EnumerationElement::ItemSequence& EnumerationElement::
    item ()
    {
      return this->item_;
    }

    void EnumerationElement::
    item (const ItemSequence& s)
    {
      this->item_ = s;
    }

    const EnumerationElement::IdType& EnumerationElement::
    id () const
    {
      return this->id_.get ();
    }

    EnumerationElement::IdType& EnumerationElement::
    id ()
    {
      return this->id_.get ();
    }

    void EnumerationElement::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void EnumerationElement::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const EnumerationElement::ClientExtensionOptional& EnumerationElement::
    clientExtension () const
    {
      return this->clientExtension_;
    }

    EnumerationElement::ClientExtensionOptional& EnumerationElement::
    clientExtension ()
    {
      return this->clientExtension_;
    }

    void EnumerationElement::
    clientExtension (const ClientExtensionType& x)
    {
      this->clientExtension_.set (x);
    }

    void EnumerationElement::
    clientExtension (const ClientExtensionOptional& x)
    {
      this->clientExtension_ = x;
    }

    void EnumerationElement::
    clientExtension (::std::unique_ptr< ClientExtensionType > x)
    {
      this->clientExtension_.set (std::move (x));
    }

    const EnumerationElement::KeyOptional& EnumerationElement::
    key () const
    {
      return this->key_;
    }

    EnumerationElement::KeyOptional& EnumerationElement::
    key ()
    {
      return this->key_;
    }

    void EnumerationElement::
    key (const KeyType& x)
    {
      this->key_.set (x);
    }

    void EnumerationElement::
    key (const KeyOptional& x)
    {
      this->key_ = x;
    }

    void EnumerationElement::
    key (::std::unique_ptr< KeyType > x)
    {
      this->key_.set (std::move (x));
    }

    const EnumerationElement::ValueNameOptional& EnumerationElement::
    valueName () const
    {
      return this->valueName_;
    }

    EnumerationElement::ValueNameOptional& EnumerationElement::
    valueName ()
    {
      return this->valueName_;
    }

    void EnumerationElement::
    valueName (const ValueNameType& x)
    {
      this->valueName_.set (x);
    }

    void EnumerationElement::
    valueName (const ValueNameOptional& x)
    {
      this->valueName_ = x;
    }

    void EnumerationElement::
    valueName (::std::unique_ptr< ValueNameType > x)
    {
      this->valueName_.set (std::move (x));
    }

    const EnumerationElement::RequiredType& EnumerationElement::
    required () const
    {
      return this->required_.get ();
    }

    EnumerationElement::RequiredType& EnumerationElement::
    required ()
    {
      return this->required_.get ();
    }

    void EnumerationElement::
    required (const RequiredType& x)
    {
      this->required_.set (x);
    }

    EnumerationElement::RequiredType EnumerationElement::
    required_default_value ()
    {
      return RequiredType (false);
    }


    // ListElement
    // 

    const ListElement::IdType& ListElement::
    id () const
    {
      return this->id_.get ();
    }

    ListElement::IdType& ListElement::
    id ()
    {
      return this->id_.get ();
    }

    void ListElement::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void ListElement::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const ListElement::ClientExtensionOptional& ListElement::
    clientExtension () const
    {
      return this->clientExtension_;
    }

    ListElement::ClientExtensionOptional& ListElement::
    clientExtension ()
    {
      return this->clientExtension_;
    }

    void ListElement::
    clientExtension (const ClientExtensionType& x)
    {
      this->clientExtension_.set (x);
    }

    void ListElement::
    clientExtension (const ClientExtensionOptional& x)
    {
      this->clientExtension_ = x;
    }

    void ListElement::
    clientExtension (::std::unique_ptr< ClientExtensionType > x)
    {
      this->clientExtension_.set (std::move (x));
    }

    const ListElement::KeyOptional& ListElement::
    key () const
    {
      return this->key_;
    }

    ListElement::KeyOptional& ListElement::
    key ()
    {
      return this->key_;
    }

    void ListElement::
    key (const KeyType& x)
    {
      this->key_.set (x);
    }

    void ListElement::
    key (const KeyOptional& x)
    {
      this->key_ = x;
    }

    void ListElement::
    key (::std::unique_ptr< KeyType > x)
    {
      this->key_.set (std::move (x));
    }

    const ListElement::ValuePrefixOptional& ListElement::
    valuePrefix () const
    {
      return this->valuePrefix_;
    }

    ListElement::ValuePrefixOptional& ListElement::
    valuePrefix ()
    {
      return this->valuePrefix_;
    }

    void ListElement::
    valuePrefix (const ValuePrefixType& x)
    {
      this->valuePrefix_.set (x);
    }

    void ListElement::
    valuePrefix (const ValuePrefixOptional& x)
    {
      this->valuePrefix_ = x;
    }

    void ListElement::
    valuePrefix (::std::unique_ptr< ValuePrefixType > x)
    {
      this->valuePrefix_.set (std::move (x));
    }

    const ListElement::AdditiveType& ListElement::
    additive () const
    {
      return this->additive_.get ();
    }

    ListElement::AdditiveType& ListElement::
    additive ()
    {
      return this->additive_.get ();
    }

    void ListElement::
    additive (const AdditiveType& x)
    {
      this->additive_.set (x);
    }

    ListElement::AdditiveType ListElement::
    additive_default_value ()
    {
      return AdditiveType (false);
    }

    const ListElement::ExpandableType& ListElement::
    expandable () const
    {
      return this->expandable_.get ();
    }

    ListElement::ExpandableType& ListElement::
    expandable ()
    {
      return this->expandable_.get ();
    }

    void ListElement::
    expandable (const ExpandableType& x)
    {
      this->expandable_.set (x);
    }

    ListElement::ExpandableType ListElement::
    expandable_default_value ()
    {
      return ExpandableType (false);
    }

    const ListElement::ExplicitValueType& ListElement::
    explicitValue () const
    {
      return this->explicitValue_.get ();
    }

    ListElement::ExplicitValueType& ListElement::
    explicitValue ()
    {
      return this->explicitValue_.get ();
    }

    void ListElement::
    explicitValue (const ExplicitValueType& x)
    {
      this->explicitValue_.set (x);
    }

    ListElement::ExplicitValueType ListElement::
    explicitValue_default_value ()
    {
      return ExplicitValueType (false);
    }


    // Value
    // 

    const Value::DeleteOptional& Value::
    delete_ () const
    {
      return this->delete__;
    }

    Value::DeleteOptional& Value::
    delete_ ()
    {
      return this->delete__;
    }

    void Value::
    delete_ (const DeleteType& x)
    {
      this->delete__.set (x);
    }

    void Value::
    delete_ (const DeleteOptional& x)
    {
      this->delete__ = x;
    }

    void Value::
    delete_ (::std::unique_ptr< DeleteType > x)
    {
      this->delete__.set (std::move (x));
    }

    const Value::DecimalOptional& Value::
    decimal () const
    {
      return this->decimal_;
    }

    Value::DecimalOptional& Value::
    decimal ()
    {
      return this->decimal_;
    }

    void Value::
    decimal (const DecimalType& x)
    {
      this->decimal_.set (x);
    }

    void Value::
    decimal (const DecimalOptional& x)
    {
      this->decimal_ = x;
    }

    void Value::
    decimal (::std::unique_ptr< DecimalType > x)
    {
      this->decimal_.set (std::move (x));
    }

    const Value::LongDecimalOptional& Value::
    longDecimal () const
    {
      return this->longDecimal_;
    }

    Value::LongDecimalOptional& Value::
    longDecimal ()
    {
      return this->longDecimal_;
    }

    void Value::
    longDecimal (const LongDecimalType& x)
    {
      this->longDecimal_.set (x);
    }

    void Value::
    longDecimal (const LongDecimalOptional& x)
    {
      this->longDecimal_ = x;
    }

    void Value::
    longDecimal (::std::unique_ptr< LongDecimalType > x)
    {
      this->longDecimal_.set (std::move (x));
    }

    const Value::StringOptional& Value::
    string () const
    {
      return this->string_;
    }

    Value::StringOptional& Value::
    string ()
    {
      return this->string_;
    }

    void Value::
    string (const StringType& x)
    {
      this->string_.set (x);
    }

    void Value::
    string (const StringOptional& x)
    {
      this->string_ = x;
    }

    void Value::
    string (::std::unique_ptr< StringType > x)
    {
      this->string_.set (std::move (x));
    }


    // ValueList
    // 

    const ValueList::ItemSequence& ValueList::
    item () const
    {
      return this->item_;
    }

    ValueList::ItemSequence& ValueList::
    item ()
    {
      return this->item_;
    }

    void ValueList::
    item (const ItemSequence& s)
    {
      this->item_ = s;
    }

    const ValueList::DefaultKeyOptional& ValueList::
    defaultKey () const
    {
      return this->defaultKey_;
    }

    ValueList::DefaultKeyOptional& ValueList::
    defaultKey ()
    {
      return this->defaultKey_;
    }

    void ValueList::
    defaultKey (const DefaultKeyType& x)
    {
      this->defaultKey_.set (x);
    }

    void ValueList::
    defaultKey (const DefaultKeyOptional& x)
    {
      this->defaultKey_ = x;
    }

    void ValueList::
    defaultKey (::std::unique_ptr< DefaultKeyType > x)
    {
      this->defaultKey_.set (std::move (x));
    }


    // ValueItem
    // 

    const ValueItem::ValueType& ValueItem::
    value () const
    {
      return this->value_.get ();
    }

    ValueItem::ValueType& ValueItem::
    value ()
    {
      return this->value_.get ();
    }

    void ValueItem::
    value (const ValueType& x)
    {
      this->value_.set (x);
    }

    void ValueItem::
    value (::std::unique_ptr< ValueType > x)
    {
      this->value_.set (std::move (x));
    }

    const ValueItem::KeyOptional& ValueItem::
    key () const
    {
      return this->key_;
    }

    ValueItem::KeyOptional& ValueItem::
    key ()
    {
      return this->key_;
    }

    void ValueItem::
    key (const KeyType& x)
    {
      this->key_.set (x);
    }

    void ValueItem::
    key (const KeyOptional& x)
    {
      this->key_ = x;
    }

    void ValueItem::
    key (::std::unique_ptr< KeyType > x)
    {
      this->key_.set (std::move (x));
    }

    const ValueItem::ValueNameType& ValueItem::
    valueName () const
    {
      return this->valueName_.get ();
    }

    ValueItem::ValueNameType& ValueItem::
    valueName ()
    {
      return this->valueName_.get ();
    }

    void ValueItem::
    valueName (const ValueNameType& x)
    {
      this->valueName_.set (x);
    }

    void ValueItem::
    valueName (::std::unique_ptr< ValueNameType > x)
    {
      this->valueName_.set (std::move (x));
    }


    // MultiTextElement
    // 

    const MultiTextElement::IdType& MultiTextElement::
    id () const
    {
      return this->id_.get ();
    }

    MultiTextElement::IdType& MultiTextElement::
    id ()
    {
      return this->id_.get ();
    }

    void MultiTextElement::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void MultiTextElement::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }

    const MultiTextElement::ClientExtensionOptional& MultiTextElement::
    clientExtension () const
    {
      return this->clientExtension_;
    }

    MultiTextElement::ClientExtensionOptional& MultiTextElement::
    clientExtension ()
    {
      return this->clientExtension_;
    }

    void MultiTextElement::
    clientExtension (const ClientExtensionType& x)
    {
      this->clientExtension_.set (x);
    }

    void MultiTextElement::
    clientExtension (const ClientExtensionOptional& x)
    {
      this->clientExtension_ = x;
    }

    void MultiTextElement::
    clientExtension (::std::unique_ptr< ClientExtensionType > x)
    {
      this->clientExtension_.set (std::move (x));
    }

    const MultiTextElement::KeyOptional& MultiTextElement::
    key () const
    {
      return this->key_;
    }

    MultiTextElement::KeyOptional& MultiTextElement::
    key ()
    {
      return this->key_;
    }

    void MultiTextElement::
    key (const KeyType& x)
    {
      this->key_.set (x);
    }

    void MultiTextElement::
    key (const KeyOptional& x)
    {
      this->key_ = x;
    }

    void MultiTextElement::
    key (::std::unique_ptr< KeyType > x)
    {
      this->key_.set (std::move (x));
    }

    const MultiTextElement::ValueNameOptional& MultiTextElement::
    valueName () const
    {
      return this->valueName_;
    }

    MultiTextElement::ValueNameOptional& MultiTextElement::
    valueName ()
    {
      return this->valueName_;
    }

    void MultiTextElement::
    valueName (const ValueNameType& x)
    {
      this->valueName_.set (x);
    }

    void MultiTextElement::
    valueName (const ValueNameOptional& x)
    {
      this->valueName_ = x;
    }

    void MultiTextElement::
    valueName (::std::unique_ptr< ValueNameType > x)
    {
      this->valueName_.set (std::move (x));
    }

    const MultiTextElement::RequiredType& MultiTextElement::
    required () const
    {
      return this->required_.get ();
    }

    MultiTextElement::RequiredType& MultiTextElement::
    required ()
    {
      return this->required_.get ();
    }

    void MultiTextElement::
    required (const RequiredType& x)
    {
      this->required_.set (x);
    }

    MultiTextElement::RequiredType MultiTextElement::
    required_default_value ()
    {
      return RequiredType (false);
    }

    const MultiTextElement::MaxLengthType& MultiTextElement::
    maxLength () const
    {
      return this->maxLength_.get ();
    }

    MultiTextElement::MaxLengthType& MultiTextElement::
    maxLength ()
    {
      return this->maxLength_.get ();
    }

    void MultiTextElement::
    maxLength (const MaxLengthType& x)
    {
      this->maxLength_.set (x);
    }

    MultiTextElement::MaxLengthType MultiTextElement::
    maxLength_default_value ()
    {
      return MaxLengthType (1023U);
    }

    const MultiTextElement::MaxStringsType& MultiTextElement::
    maxStrings () const
    {
      return this->maxStrings_.get ();
    }

    MultiTextElement::MaxStringsType& MultiTextElement::
    maxStrings ()
    {
      return this->maxStrings_.get ();
    }

    void MultiTextElement::
    maxStrings (const MaxStringsType& x)
    {
      this->maxStrings_.set (x);
    }

    MultiTextElement::MaxStringsType MultiTextElement::
    maxStrings_default_value ()
    {
      return MaxStringsType (0U);
    }

    const MultiTextElement::SoftType& MultiTextElement::
    soft () const
    {
      return this->soft_.get ();
    }

    MultiTextElement::SoftType& MultiTextElement::
    soft ()
    {
      return this->soft_.get ();
    }

    void MultiTextElement::
    soft (const SoftType& x)
    {
      this->soft_.set (x);
    }

    MultiTextElement::SoftType MultiTextElement::
    soft_default_value ()
    {
      return SoftType (false);
    }


    // DataElementContent
    // 

    const DataElementContent::RefIdType& DataElementContent::
    refId () const
    {
      return this->refId_.get ();
    }

    DataElementContent::RefIdType& DataElementContent::
    refId ()
    {
      return this->refId_.get ();
    }

    void DataElementContent::
    refId (const RefIdType& x)
    {
      this->refId_.set (x);
    }

    void DataElementContent::
    refId (::std::unique_ptr< RefIdType > x)
    {
      this->refId_.set (std::move (x));
    }


    // DataElement
    // 

    const DataElement::RefIdType& DataElement::
    refId () const
    {
      return this->refId_.get ();
    }

    DataElement::RefIdType& DataElement::
    refId ()
    {
      return this->refId_.get ();
    }

    void DataElement::
    refId (const RefIdType& x)
    {
      this->refId_.set (x);
    }

    void DataElement::
    refId (::std::unique_ptr< RefIdType > x)
    {
      this->refId_.set (std::move (x));
    }


    // DecimalTextBox
    // 

    const DecimalTextBox::DefaultValueType& DecimalTextBox::
    defaultValue () const
    {
      return this->defaultValue_.get ();
    }

    DecimalTextBox::DefaultValueType& DecimalTextBox::
    defaultValue ()
    {
      return this->defaultValue_.get ();
    }

    void DecimalTextBox::
    defaultValue (const DefaultValueType& x)
    {
      this->defaultValue_.set (x);
    }

    DecimalTextBox::DefaultValueType DecimalTextBox::
    defaultValue_default_value ()
    {
      return DefaultValueType (1U);
    }

    const DecimalTextBox::SpinType& DecimalTextBox::
    spin () const
    {
      return this->spin_.get ();
    }

    DecimalTextBox::SpinType& DecimalTextBox::
    spin ()
    {
      return this->spin_.get ();
    }

    void DecimalTextBox::
    spin (const SpinType& x)
    {
      this->spin_.set (x);
    }

    DecimalTextBox::SpinType DecimalTextBox::
    spin_default_value ()
    {
      return SpinType (true);
    }

    const DecimalTextBox::SpinStepType& DecimalTextBox::
    spinStep () const
    {
      return this->spinStep_.get ();
    }

    DecimalTextBox::SpinStepType& DecimalTextBox::
    spinStep ()
    {
      return this->spinStep_.get ();
    }

    void DecimalTextBox::
    spinStep (const SpinStepType& x)
    {
      this->spinStep_.set (x);
    }

    DecimalTextBox::SpinStepType DecimalTextBox::
    spinStep_default_value ()
    {
      return SpinStepType (1U);
    }


    // LongDecimalTextBox
    // 

    const LongDecimalTextBox::DefaultValueType& LongDecimalTextBox::
    defaultValue () const
    {
      return this->defaultValue_.get ();
    }

    LongDecimalTextBox::DefaultValueType& LongDecimalTextBox::
    defaultValue ()
    {
      return this->defaultValue_.get ();
    }

    void LongDecimalTextBox::
    defaultValue (const DefaultValueType& x)
    {
      this->defaultValue_.set (x);
    }

    LongDecimalTextBox::DefaultValueType LongDecimalTextBox::
    defaultValue_default_value ()
    {
      return DefaultValueType (1U);
    }

    const LongDecimalTextBox::SpinType& LongDecimalTextBox::
    spin () const
    {
      return this->spin_.get ();
    }

    LongDecimalTextBox::SpinType& LongDecimalTextBox::
    spin ()
    {
      return this->spin_.get ();
    }

    void LongDecimalTextBox::
    spin (const SpinType& x)
    {
      this->spin_.set (x);
    }

    LongDecimalTextBox::SpinType LongDecimalTextBox::
    spin_default_value ()
    {
      return SpinType (true);
    }

    const LongDecimalTextBox::SpinStepType& LongDecimalTextBox::
    spinStep () const
    {
      return this->spinStep_.get ();
    }

    LongDecimalTextBox::SpinStepType& LongDecimalTextBox::
    spinStep ()
    {
      return this->spinStep_.get ();
    }

    void LongDecimalTextBox::
    spinStep (const SpinStepType& x)
    {
      this->spinStep_.set (x);
    }

    LongDecimalTextBox::SpinStepType LongDecimalTextBox::
    spinStep_default_value ()
    {
      return SpinStepType (1U);
    }


    // TextBox
    // 

    const TextBox::LabelType& TextBox::
    label () const
    {
      return this->label_.get ();
    }

    TextBox::LabelType& TextBox::
    label ()
    {
      return this->label_.get ();
    }

    void TextBox::
    label (const LabelType& x)
    {
      this->label_.set (x);
    }

    void TextBox::
    label (::std::unique_ptr< LabelType > x)
    {
      this->label_.set (std::move (x));
    }

    const TextBox::DefaultValueOptional& TextBox::
    defaultValue () const
    {
      return this->defaultValue_;
    }

    TextBox::DefaultValueOptional& TextBox::
    defaultValue ()
    {
      return this->defaultValue_;
    }

    void TextBox::
    defaultValue (const DefaultValueType& x)
    {
      this->defaultValue_.set (x);
    }

    void TextBox::
    defaultValue (const DefaultValueOptional& x)
    {
      this->defaultValue_ = x;
    }

    void TextBox::
    defaultValue (::std::unique_ptr< DefaultValueType > x)
    {
      this->defaultValue_.set (std::move (x));
    }


    // MultiTextBox
    // 

    const MultiTextBox::ShowAsDialogType& MultiTextBox::
    showAsDialog () const
    {
      return this->showAsDialog_.get ();
    }

    MultiTextBox::ShowAsDialogType& MultiTextBox::
    showAsDialog ()
    {
      return this->showAsDialog_.get ();
    }

    void MultiTextBox::
    showAsDialog (const ShowAsDialogType& x)
    {
      this->showAsDialog_.set (x);
    }

    MultiTextBox::ShowAsDialogType MultiTextBox::
    showAsDialog_default_value ()
    {
      return ShowAsDialogType (false);
    }

    const MultiTextBox::DefaultHeightType& MultiTextBox::
    defaultHeight () const
    {
      return this->defaultHeight_.get ();
    }

    MultiTextBox::DefaultHeightType& MultiTextBox::
    defaultHeight ()
    {
      return this->defaultHeight_.get ();
    }

    void MultiTextBox::
    defaultHeight (const DefaultHeightType& x)
    {
      this->defaultHeight_.set (x);
    }

    MultiTextBox::DefaultHeightType MultiTextBox::
    defaultHeight_default_value ()
    {
      return DefaultHeightType (3U);
    }


    // CheckBox
    // 

    const CheckBox::DefaultCheckedType& CheckBox::
    defaultChecked () const
    {
      return this->defaultChecked_.get ();
    }

    CheckBox::DefaultCheckedType& CheckBox::
    defaultChecked ()
    {
      return this->defaultChecked_.get ();
    }

    void CheckBox::
    defaultChecked (const DefaultCheckedType& x)
    {
      this->defaultChecked_.set (x);
    }

    CheckBox::DefaultCheckedType CheckBox::
    defaultChecked_default_value ()
    {
      return DefaultCheckedType (false);
    }


    // ComboBox
    // 

    const ComboBox::LabelType& ComboBox::
    label () const
    {
      return this->label_.get ();
    }

    ComboBox::LabelType& ComboBox::
    label ()
    {
      return this->label_.get ();
    }

    void ComboBox::
    label (const LabelType& x)
    {
      this->label_.set (x);
    }

    void ComboBox::
    label (::std::unique_ptr< LabelType > x)
    {
      this->label_.set (std::move (x));
    }

    const ComboBox::DefaultOptional& ComboBox::
    default_ () const
    {
      return this->default__;
    }

    ComboBox::DefaultOptional& ComboBox::
    default_ ()
    {
      return this->default__;
    }

    void ComboBox::
    default_ (const DefaultType& x)
    {
      this->default__.set (x);
    }

    void ComboBox::
    default_ (const DefaultOptional& x)
    {
      this->default__ = x;
    }

    void ComboBox::
    default_ (::std::unique_ptr< DefaultType > x)
    {
      this->default__.set (std::move (x));
    }

    const ComboBox::SuggestionSequence& ComboBox::
    suggestion () const
    {
      return this->suggestion_;
    }

    ComboBox::SuggestionSequence& ComboBox::
    suggestion ()
    {
      return this->suggestion_;
    }

    void ComboBox::
    suggestion (const SuggestionSequence& s)
    {
      this->suggestion_ = s;
    }

    const ComboBox::NoSortType& ComboBox::
    noSort () const
    {
      return this->noSort_.get ();
    }

    ComboBox::NoSortType& ComboBox::
    noSort ()
    {
      return this->noSort_.get ();
    }

    void ComboBox::
    noSort (const NoSortType& x)
    {
      this->noSort_.set (x);
    }

    ComboBox::NoSortType ComboBox::
    noSort_default_value ()
    {
      return NoSortType (false);
    }


    // DropdownList
    // 

    const DropdownList::NoSortType& DropdownList::
    noSort () const
    {
      return this->noSort_.get ();
    }

    DropdownList::NoSortType& DropdownList::
    noSort ()
    {
      return this->noSort_.get ();
    }

    void DropdownList::
    noSort (const NoSortType& x)
    {
      this->noSort_.set (x);
    }

    DropdownList::NoSortType DropdownList::
    noSort_default_value ()
    {
      return NoSortType (false);
    }

    const DropdownList::DefaultItemOptional& DropdownList::
    defaultItem () const
    {
      return this->defaultItem_;
    }

    DropdownList::DefaultItemOptional& DropdownList::
    defaultItem ()
    {
      return this->defaultItem_;
    }

    void DropdownList::
    defaultItem (const DefaultItemType& x)
    {
      this->defaultItem_.set (x);
    }

    void DropdownList::
    defaultItem (const DefaultItemOptional& x)
    {
      this->defaultItem_ = x;
    }


    // ListBox
    // 


    // PolicyPresentation
    // 

    const PolicyPresentation::TextSequence& PolicyPresentation::
    text () const
    {
      return this->text_;
    }

    PolicyPresentation::TextSequence& PolicyPresentation::
    text ()
    {
      return this->text_;
    }

    void PolicyPresentation::
    text (const TextSequence& s)
    {
      this->text_ = s;
    }

    const PolicyPresentation::DecimalTextBoxSequence& PolicyPresentation::
    decimalTextBox () const
    {
      return this->decimalTextBox_;
    }

    PolicyPresentation::DecimalTextBoxSequence& PolicyPresentation::
    decimalTextBox ()
    {
      return this->decimalTextBox_;
    }

    void PolicyPresentation::
    decimalTextBox (const DecimalTextBoxSequence& s)
    {
      this->decimalTextBox_ = s;
    }

    const PolicyPresentation::TextBoxSequence& PolicyPresentation::
    textBox () const
    {
      return this->textBox_;
    }

    PolicyPresentation::TextBoxSequence& PolicyPresentation::
    textBox ()
    {
      return this->textBox_;
    }

    void PolicyPresentation::
    textBox (const TextBoxSequence& s)
    {
      this->textBox_ = s;
    }

    const PolicyPresentation::CheckBoxSequence& PolicyPresentation::
    checkBox () const
    {
      return this->checkBox_;
    }

    PolicyPresentation::CheckBoxSequence& PolicyPresentation::
    checkBox ()
    {
      return this->checkBox_;
    }

    void PolicyPresentation::
    checkBox (const CheckBoxSequence& s)
    {
      this->checkBox_ = s;
    }

    const PolicyPresentation::ComboBoxSequence& PolicyPresentation::
    comboBox () const
    {
      return this->comboBox_;
    }

    PolicyPresentation::ComboBoxSequence& PolicyPresentation::
    comboBox ()
    {
      return this->comboBox_;
    }

    void PolicyPresentation::
    comboBox (const ComboBoxSequence& s)
    {
      this->comboBox_ = s;
    }

    const PolicyPresentation::DropdownListSequence& PolicyPresentation::
    dropdownList () const
    {
      return this->dropdownList_;
    }

    PolicyPresentation::DropdownListSequence& PolicyPresentation::
    dropdownList ()
    {
      return this->dropdownList_;
    }

    void PolicyPresentation::
    dropdownList (const DropdownListSequence& s)
    {
      this->dropdownList_ = s;
    }

    const PolicyPresentation::ListBoxSequence& PolicyPresentation::
    listBox () const
    {
      return this->listBox_;
    }

    PolicyPresentation::ListBoxSequence& PolicyPresentation::
    listBox ()
    {
      return this->listBox_;
    }

    void PolicyPresentation::
    listBox (const ListBoxSequence& s)
    {
      this->listBox_ = s;
    }

    const PolicyPresentation::LongDecimalTextBoxSequence& PolicyPresentation::
    longDecimalTextBox () const
    {
      return this->longDecimalTextBox_;
    }

    PolicyPresentation::LongDecimalTextBoxSequence& PolicyPresentation::
    longDecimalTextBox ()
    {
      return this->longDecimalTextBox_;
    }

    void PolicyPresentation::
    longDecimalTextBox (const LongDecimalTextBoxSequence& s)
    {
      this->longDecimalTextBox_ = s;
    }

    const PolicyPresentation::MultiTextBoxSequence& PolicyPresentation::
    multiTextBox () const
    {
      return this->multiTextBox_;
    }

    PolicyPresentation::MultiTextBoxSequence& PolicyPresentation::
    multiTextBox ()
    {
      return this->multiTextBox_;
    }

    void PolicyPresentation::
    multiTextBox (const MultiTextBoxSequence& s)
    {
      this->multiTextBox_ = s;
    }

    const PolicyPresentation::IdType& PolicyPresentation::
    id () const
    {
      return this->id_.get ();
    }

    PolicyPresentation::IdType& PolicyPresentation::
    id ()
    {
      return this->id_.get ();
    }

    void PolicyPresentation::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void PolicyPresentation::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }


    // CategoryReference
    // 

    const CategoryReference::RefType& CategoryReference::
    ref () const
    {
      return this->ref_.get ();
    }

    CategoryReference::RefType& CategoryReference::
    ref ()
    {
      return this->ref_.get ();
    }

    void CategoryReference::
    ref (const RefType& x)
    {
      this->ref_.set (x);
    }

    void CategoryReference::
    ref (::std::unique_ptr< RefType > x)
    {
      this->ref_.set (std::move (x));
    }


    // Category
    // 

    const Category::AnnotationSequence& Category::
    annotation () const
    {
      return this->annotation_;
    }

    Category::AnnotationSequence& Category::
    annotation ()
    {
      return this->annotation_;
    }

    void Category::
    annotation (const AnnotationSequence& s)
    {
      this->annotation_ = s;
    }

    const Category::ParentCategoryOptional& Category::
    parentCategory () const
    {
      return this->parentCategory_;
    }

    Category::ParentCategoryOptional& Category::
    parentCategory ()
    {
      return this->parentCategory_;
    }

    void Category::
    parentCategory (const ParentCategoryType& x)
    {
      this->parentCategory_.set (x);
    }

    void Category::
    parentCategory (const ParentCategoryOptional& x)
    {
      this->parentCategory_ = x;
    }

    void Category::
    parentCategory (::std::unique_ptr< ParentCategoryType > x)
    {
      this->parentCategory_.set (std::move (x));
    }

    const Category::SeeAlsoSequence& Category::
    seeAlso () const
    {
      return this->seeAlso_;
    }

    Category::SeeAlsoSequence& Category::
    seeAlso ()
    {
      return this->seeAlso_;
    }

    void Category::
    seeAlso (const SeeAlsoSequence& s)
    {
      this->seeAlso_ = s;
    }

    const Category::KeywordsOptional& Category::
    keywords () const
    {
      return this->keywords_;
    }

    Category::KeywordsOptional& Category::
    keywords ()
    {
      return this->keywords_;
    }

    void Category::
    keywords (const KeywordsType& x)
    {
      this->keywords_.set (x);
    }

    void Category::
    keywords (const KeywordsOptional& x)
    {
      this->keywords_ = x;
    }

    void Category::
    keywords (::std::unique_ptr< KeywordsType > x)
    {
      this->keywords_.set (std::move (x));
    }

    const Category::NameType& Category::
    name () const
    {
      return this->name_.get ();
    }

    Category::NameType& Category::
    name ()
    {
      return this->name_.get ();
    }

    void Category::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void Category::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const Category::DisplayNameType& Category::
    displayName () const
    {
      return this->displayName_.get ();
    }

    Category::DisplayNameType& Category::
    displayName ()
    {
      return this->displayName_.get ();
    }

    void Category::
    displayName (const DisplayNameType& x)
    {
      this->displayName_.set (x);
    }

    void Category::
    displayName (::std::unique_ptr< DisplayNameType > x)
    {
      this->displayName_.set (std::move (x));
    }

    const Category::ExplainTextOptional& Category::
    explainText () const
    {
      return this->explainText_;
    }

    Category::ExplainTextOptional& Category::
    explainText ()
    {
      return this->explainText_;
    }

    void Category::
    explainText (const ExplainTextType& x)
    {
      this->explainText_.set (x);
    }

    void Category::
    explainText (const ExplainTextOptional& x)
    {
      this->explainText_ = x;
    }

    void Category::
    explainText (::std::unique_ptr< ExplainTextType > x)
    {
      this->explainText_.set (std::move (x));
    }


    // SupportedProducts
    // 

    const SupportedProducts::ProductSequence& SupportedProducts::
    product () const
    {
      return this->product_;
    }

    SupportedProducts::ProductSequence& SupportedProducts::
    product ()
    {
      return this->product_;
    }

    void SupportedProducts::
    product (const ProductSequence& s)
    {
      this->product_ = s;
    }


    // SupportedProduct
    // 

    const SupportedProduct::MajorVersionSequence& SupportedProduct::
    majorVersion () const
    {
      return this->majorVersion_;
    }

    SupportedProduct::MajorVersionSequence& SupportedProduct::
    majorVersion ()
    {
      return this->majorVersion_;
    }

    void SupportedProduct::
    majorVersion (const MajorVersionSequence& s)
    {
      this->majorVersion_ = s;
    }

    const SupportedProduct::NameType& SupportedProduct::
    name () const
    {
      return this->name_.get ();
    }

    SupportedProduct::NameType& SupportedProduct::
    name ()
    {
      return this->name_.get ();
    }

    void SupportedProduct::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void SupportedProduct::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const SupportedProduct::DisplayNameType& SupportedProduct::
    displayName () const
    {
      return this->displayName_.get ();
    }

    SupportedProduct::DisplayNameType& SupportedProduct::
    displayName ()
    {
      return this->displayName_.get ();
    }

    void SupportedProduct::
    displayName (const DisplayNameType& x)
    {
      this->displayName_.set (x);
    }

    void SupportedProduct::
    displayName (::std::unique_ptr< DisplayNameType > x)
    {
      this->displayName_.set (std::move (x));
    }


    // SupportedMajorVersion
    // 

    const SupportedMajorVersion::MinorVersionSequence& SupportedMajorVersion::
    minorVersion () const
    {
      return this->minorVersion_;
    }

    SupportedMajorVersion::MinorVersionSequence& SupportedMajorVersion::
    minorVersion ()
    {
      return this->minorVersion_;
    }

    void SupportedMajorVersion::
    minorVersion (const MinorVersionSequence& s)
    {
      this->minorVersion_ = s;
    }

    const SupportedMajorVersion::NameType& SupportedMajorVersion::
    name () const
    {
      return this->name_.get ();
    }

    SupportedMajorVersion::NameType& SupportedMajorVersion::
    name ()
    {
      return this->name_.get ();
    }

    void SupportedMajorVersion::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void SupportedMajorVersion::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const SupportedMajorVersion::DisplayNameType& SupportedMajorVersion::
    displayName () const
    {
      return this->displayName_.get ();
    }

    SupportedMajorVersion::DisplayNameType& SupportedMajorVersion::
    displayName ()
    {
      return this->displayName_.get ();
    }

    void SupportedMajorVersion::
    displayName (const DisplayNameType& x)
    {
      this->displayName_.set (x);
    }

    void SupportedMajorVersion::
    displayName (::std::unique_ptr< DisplayNameType > x)
    {
      this->displayName_.set (std::move (x));
    }

    const SupportedMajorVersion::VersionIndexType& SupportedMajorVersion::
    versionIndex () const
    {
      return this->versionIndex_.get ();
    }

    SupportedMajorVersion::VersionIndexType& SupportedMajorVersion::
    versionIndex ()
    {
      return this->versionIndex_.get ();
    }

    void SupportedMajorVersion::
    versionIndex (const VersionIndexType& x)
    {
      this->versionIndex_.set (x);
    }


    // SupportedMinorVersion
    // 

    const SupportedMinorVersion::DisplayNameType& SupportedMinorVersion::
    displayName () const
    {
      return this->displayName_.get ();
    }

    SupportedMinorVersion::DisplayNameType& SupportedMinorVersion::
    displayName ()
    {
      return this->displayName_.get ();
    }

    void SupportedMinorVersion::
    displayName (const DisplayNameType& x)
    {
      this->displayName_.set (x);
    }

    void SupportedMinorVersion::
    displayName (::std::unique_ptr< DisplayNameType > x)
    {
      this->displayName_.set (std::move (x));
    }

    const SupportedMinorVersion::NameType& SupportedMinorVersion::
    name () const
    {
      return this->name_.get ();
    }

    SupportedMinorVersion::NameType& SupportedMinorVersion::
    name ()
    {
      return this->name_.get ();
    }

    void SupportedMinorVersion::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void SupportedMinorVersion::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const SupportedMinorVersion::VersionIndexType& SupportedMinorVersion::
    versionIndex () const
    {
      return this->versionIndex_.get ();
    }

    SupportedMinorVersion::VersionIndexType& SupportedMinorVersion::
    versionIndex ()
    {
      return this->versionIndex_.get ();
    }

    void SupportedMinorVersion::
    versionIndex (const VersionIndexType& x)
    {
      this->versionIndex_.set (x);
    }


    // SupportedOnReference
    // 

    const SupportedOnReference::RefType& SupportedOnReference::
    ref () const
    {
      return this->ref_.get ();
    }

    SupportedOnReference::RefType& SupportedOnReference::
    ref ()
    {
      return this->ref_.get ();
    }

    void SupportedOnReference::
    ref (const RefType& x)
    {
      this->ref_.set (x);
    }

    void SupportedOnReference::
    ref (::std::unique_ptr< RefType > x)
    {
      this->ref_.set (std::move (x));
    }


    // SupportedOnRange
    // 

    const SupportedOnRange::RefType& SupportedOnRange::
    ref () const
    {
      return this->ref_.get ();
    }

    SupportedOnRange::RefType& SupportedOnRange::
    ref ()
    {
      return this->ref_.get ();
    }

    void SupportedOnRange::
    ref (const RefType& x)
    {
      this->ref_.set (x);
    }

    void SupportedOnRange::
    ref (::std::unique_ptr< RefType > x)
    {
      this->ref_.set (std::move (x));
    }

    const SupportedOnRange::MinVersionIndexOptional& SupportedOnRange::
    minVersionIndex () const
    {
      return this->minVersionIndex_;
    }

    SupportedOnRange::MinVersionIndexOptional& SupportedOnRange::
    minVersionIndex ()
    {
      return this->minVersionIndex_;
    }

    void SupportedOnRange::
    minVersionIndex (const MinVersionIndexType& x)
    {
      this->minVersionIndex_.set (x);
    }

    void SupportedOnRange::
    minVersionIndex (const MinVersionIndexOptional& x)
    {
      this->minVersionIndex_ = x;
    }

    const SupportedOnRange::MaxVersionIndexOptional& SupportedOnRange::
    maxVersionIndex () const
    {
      return this->maxVersionIndex_;
    }

    SupportedOnRange::MaxVersionIndexOptional& SupportedOnRange::
    maxVersionIndex ()
    {
      return this->maxVersionIndex_;
    }

    void SupportedOnRange::
    maxVersionIndex (const MaxVersionIndexType& x)
    {
      this->maxVersionIndex_.set (x);
    }

    void SupportedOnRange::
    maxVersionIndex (const MaxVersionIndexOptional& x)
    {
      this->maxVersionIndex_ = x;
    }


    // SupportedAndCondition
    // 

    const SupportedAndCondition::RangeSequence& SupportedAndCondition::
    range () const
    {
      return this->range_;
    }

    SupportedAndCondition::RangeSequence& SupportedAndCondition::
    range ()
    {
      return this->range_;
    }

    void SupportedAndCondition::
    range (const RangeSequence& s)
    {
      this->range_ = s;
    }

    const SupportedAndCondition::ReferenceSequence& SupportedAndCondition::
    reference () const
    {
      return this->reference_;
    }

    SupportedAndCondition::ReferenceSequence& SupportedAndCondition::
    reference ()
    {
      return this->reference_;
    }

    void SupportedAndCondition::
    reference (const ReferenceSequence& s)
    {
      this->reference_ = s;
    }


    // SupportedOrCondition
    // 

    const SupportedOrCondition::RangeSequence& SupportedOrCondition::
    range () const
    {
      return this->range_;
    }

    SupportedOrCondition::RangeSequence& SupportedOrCondition::
    range ()
    {
      return this->range_;
    }

    void SupportedOrCondition::
    range (const RangeSequence& s)
    {
      this->range_ = s;
    }

    const SupportedOrCondition::ReferenceSequence& SupportedOrCondition::
    reference () const
    {
      return this->reference_;
    }

    SupportedOrCondition::ReferenceSequence& SupportedOrCondition::
    reference ()
    {
      return this->reference_;
    }

    void SupportedOrCondition::
    reference (const ReferenceSequence& s)
    {
      this->reference_ = s;
    }


    // SupportedOnDefinition
    // 

    const SupportedOnDefinition::OrOptional& SupportedOnDefinition::
    or_ () const
    {
      return this->or__;
    }

    SupportedOnDefinition::OrOptional& SupportedOnDefinition::
    or_ ()
    {
      return this->or__;
    }

    void SupportedOnDefinition::
    or_ (const OrType& x)
    {
      this->or__.set (x);
    }

    void SupportedOnDefinition::
    or_ (const OrOptional& x)
    {
      this->or__ = x;
    }

    void SupportedOnDefinition::
    or_ (::std::unique_ptr< OrType > x)
    {
      this->or__.set (std::move (x));
    }

    const SupportedOnDefinition::AndOptional& SupportedOnDefinition::
    and_ () const
    {
      return this->and__;
    }

    SupportedOnDefinition::AndOptional& SupportedOnDefinition::
    and_ ()
    {
      return this->and__;
    }

    void SupportedOnDefinition::
    and_ (const AndType& x)
    {
      this->and__.set (x);
    }

    void SupportedOnDefinition::
    and_ (const AndOptional& x)
    {
      this->and__ = x;
    }

    void SupportedOnDefinition::
    and_ (::std::unique_ptr< AndType > x)
    {
      this->and__.set (std::move (x));
    }

    const SupportedOnDefinition::NameType& SupportedOnDefinition::
    name () const
    {
      return this->name_.get ();
    }

    SupportedOnDefinition::NameType& SupportedOnDefinition::
    name ()
    {
      return this->name_.get ();
    }

    void SupportedOnDefinition::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void SupportedOnDefinition::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const SupportedOnDefinition::DisplayNameType& SupportedOnDefinition::
    displayName () const
    {
      return this->displayName_.get ();
    }

    SupportedOnDefinition::DisplayNameType& SupportedOnDefinition::
    displayName ()
    {
      return this->displayName_.get ();
    }

    void SupportedOnDefinition::
    displayName (const DisplayNameType& x)
    {
      this->displayName_.set (x);
    }

    void SupportedOnDefinition::
    displayName (::std::unique_ptr< DisplayNameType > x)
    {
      this->displayName_.set (std::move (x));
    }


    // SupportedOnDefinitions
    // 

    const SupportedOnDefinitions::DefinitionSequence& SupportedOnDefinitions::
    definition () const
    {
      return this->definition_;
    }

    SupportedOnDefinitions::DefinitionSequence& SupportedOnDefinitions::
    definition ()
    {
      return this->definition_;
    }

    void SupportedOnDefinitions::
    definition (const DefinitionSequence& s)
    {
      this->definition_ = s;
    }


    // PolicyClass
    // 

    PolicyClass::
    PolicyClass (Value v)
    : ::xml_schema::Token (_xsd_PolicyClass_literals_[v])
    {
    }

    PolicyClass::
    PolicyClass (const char* v)
    : ::xml_schema::Token (v)
    {
    }

    PolicyClass::
    PolicyClass (const ::std::string& v)
    : ::xml_schema::Token (v)
    {
    }

    PolicyClass::
    PolicyClass (const ::xml_schema::Token& v)
    : ::xml_schema::Token (v)
    {
    }

    PolicyClass::
    PolicyClass (const PolicyClass& v,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Token (v, f, c)
    {
    }

    PolicyClass& PolicyClass::
    operator= (Value v)
    {
      static_cast< ::xml_schema::Token& > (*this) = 
      ::xml_schema::Token (_xsd_PolicyClass_literals_[v]);

      return *this;
    }


    // PolicyDefinition
    // 

    const PolicyDefinition::AnnotationSequence& PolicyDefinition::
    annotation () const
    {
      return this->annotation_;
    }

    PolicyDefinition::AnnotationSequence& PolicyDefinition::
    annotation ()
    {
      return this->annotation_;
    }

    void PolicyDefinition::
    annotation (const AnnotationSequence& s)
    {
      this->annotation_ = s;
    }

    const PolicyDefinition::ParentCategoryOptional& PolicyDefinition::
    parentCategory () const
    {
      return this->parentCategory_;
    }

    PolicyDefinition::ParentCategoryOptional& PolicyDefinition::
    parentCategory ()
    {
      return this->parentCategory_;
    }

    void PolicyDefinition::
    parentCategory (const ParentCategoryType& x)
    {
      this->parentCategory_.set (x);
    }

    void PolicyDefinition::
    parentCategory (const ParentCategoryOptional& x)
    {
      this->parentCategory_ = x;
    }

    void PolicyDefinition::
    parentCategory (::std::unique_ptr< ParentCategoryType > x)
    {
      this->parentCategory_.set (std::move (x));
    }

    const PolicyDefinition::SeeAlsoSequence& PolicyDefinition::
    seeAlso () const
    {
      return this->seeAlso_;
    }

    PolicyDefinition::SeeAlsoSequence& PolicyDefinition::
    seeAlso ()
    {
      return this->seeAlso_;
    }

    void PolicyDefinition::
    seeAlso (const SeeAlsoSequence& s)
    {
      this->seeAlso_ = s;
    }

    const PolicyDefinition::KeywordsOptional& PolicyDefinition::
    keywords () const
    {
      return this->keywords_;
    }

    PolicyDefinition::KeywordsOptional& PolicyDefinition::
    keywords ()
    {
      return this->keywords_;
    }

    void PolicyDefinition::
    keywords (const KeywordsType& x)
    {
      this->keywords_.set (x);
    }

    void PolicyDefinition::
    keywords (const KeywordsOptional& x)
    {
      this->keywords_ = x;
    }

    void PolicyDefinition::
    keywords (::std::unique_ptr< KeywordsType > x)
    {
      this->keywords_.set (std::move (x));
    }

    const PolicyDefinition::SupportedOnType& PolicyDefinition::
    supportedOn () const
    {
      return this->supportedOn_.get ();
    }

    PolicyDefinition::SupportedOnType& PolicyDefinition::
    supportedOn ()
    {
      return this->supportedOn_.get ();
    }

    void PolicyDefinition::
    supportedOn (const SupportedOnType& x)
    {
      this->supportedOn_.set (x);
    }

    void PolicyDefinition::
    supportedOn (::std::unique_ptr< SupportedOnType > x)
    {
      this->supportedOn_.set (std::move (x));
    }

    const PolicyDefinition::EnabledValueOptional& PolicyDefinition::
    enabledValue () const
    {
      return this->enabledValue_;
    }

    PolicyDefinition::EnabledValueOptional& PolicyDefinition::
    enabledValue ()
    {
      return this->enabledValue_;
    }

    void PolicyDefinition::
    enabledValue (const EnabledValueType& x)
    {
      this->enabledValue_.set (x);
    }

    void PolicyDefinition::
    enabledValue (const EnabledValueOptional& x)
    {
      this->enabledValue_ = x;
    }

    void PolicyDefinition::
    enabledValue (::std::unique_ptr< EnabledValueType > x)
    {
      this->enabledValue_.set (std::move (x));
    }

    const PolicyDefinition::DisabledValueOptional& PolicyDefinition::
    disabledValue () const
    {
      return this->disabledValue_;
    }

    PolicyDefinition::DisabledValueOptional& PolicyDefinition::
    disabledValue ()
    {
      return this->disabledValue_;
    }

    void PolicyDefinition::
    disabledValue (const DisabledValueType& x)
    {
      this->disabledValue_.set (x);
    }

    void PolicyDefinition::
    disabledValue (const DisabledValueOptional& x)
    {
      this->disabledValue_ = x;
    }

    void PolicyDefinition::
    disabledValue (::std::unique_ptr< DisabledValueType > x)
    {
      this->disabledValue_.set (std::move (x));
    }

    const PolicyDefinition::EnabledListOptional& PolicyDefinition::
    enabledList () const
    {
      return this->enabledList_;
    }

    PolicyDefinition::EnabledListOptional& PolicyDefinition::
    enabledList ()
    {
      return this->enabledList_;
    }

    void PolicyDefinition::
    enabledList (const EnabledListType& x)
    {
      this->enabledList_.set (x);
    }

    void PolicyDefinition::
    enabledList (const EnabledListOptional& x)
    {
      this->enabledList_ = x;
    }

    void PolicyDefinition::
    enabledList (::std::unique_ptr< EnabledListType > x)
    {
      this->enabledList_.set (std::move (x));
    }

    const PolicyDefinition::DisabledListOptional& PolicyDefinition::
    disabledList () const
    {
      return this->disabledList_;
    }

    PolicyDefinition::DisabledListOptional& PolicyDefinition::
    disabledList ()
    {
      return this->disabledList_;
    }

    void PolicyDefinition::
    disabledList (const DisabledListType& x)
    {
      this->disabledList_.set (x);
    }

    void PolicyDefinition::
    disabledList (const DisabledListOptional& x)
    {
      this->disabledList_ = x;
    }

    void PolicyDefinition::
    disabledList (::std::unique_ptr< DisabledListType > x)
    {
      this->disabledList_.set (std::move (x));
    }

    const PolicyDefinition::ElementsOptional& PolicyDefinition::
    elements () const
    {
      return this->elements_;
    }

    PolicyDefinition::ElementsOptional& PolicyDefinition::
    elements ()
    {
      return this->elements_;
    }

    void PolicyDefinition::
    elements (const ElementsType& x)
    {
      this->elements_.set (x);
    }

    void PolicyDefinition::
    elements (const ElementsOptional& x)
    {
      this->elements_ = x;
    }

    void PolicyDefinition::
    elements (::std::unique_ptr< ElementsType > x)
    {
      this->elements_.set (std::move (x));
    }

    const PolicyDefinition::NameType& PolicyDefinition::
    name () const
    {
      return this->name_.get ();
    }

    PolicyDefinition::NameType& PolicyDefinition::
    name ()
    {
      return this->name_.get ();
    }

    void PolicyDefinition::
    name (const NameType& x)
    {
      this->name_.set (x);
    }

    void PolicyDefinition::
    name (::std::unique_ptr< NameType > x)
    {
      this->name_.set (std::move (x));
    }

    const PolicyDefinition::ClassType& PolicyDefinition::
    class_ () const
    {
      return this->class__.get ();
    }

    PolicyDefinition::ClassType& PolicyDefinition::
    class_ ()
    {
      return this->class__.get ();
    }

    void PolicyDefinition::
    class_ (const ClassType& x)
    {
      this->class__.set (x);
    }

    void PolicyDefinition::
    class_ (::std::unique_ptr< ClassType > x)
    {
      this->class__.set (std::move (x));
    }

    const PolicyDefinition::DisplayNameType& PolicyDefinition::
    displayName () const
    {
      return this->displayName_.get ();
    }

    PolicyDefinition::DisplayNameType& PolicyDefinition::
    displayName ()
    {
      return this->displayName_.get ();
    }

    void PolicyDefinition::
    displayName (const DisplayNameType& x)
    {
      this->displayName_.set (x);
    }

    void PolicyDefinition::
    displayName (::std::unique_ptr< DisplayNameType > x)
    {
      this->displayName_.set (std::move (x));
    }

    const PolicyDefinition::ExplainTextOptional& PolicyDefinition::
    explainText () const
    {
      return this->explainText_;
    }

    PolicyDefinition::ExplainTextOptional& PolicyDefinition::
    explainText ()
    {
      return this->explainText_;
    }

    void PolicyDefinition::
    explainText (const ExplainTextType& x)
    {
      this->explainText_.set (x);
    }

    void PolicyDefinition::
    explainText (const ExplainTextOptional& x)
    {
      this->explainText_ = x;
    }

    void PolicyDefinition::
    explainText (::std::unique_ptr< ExplainTextType > x)
    {
      this->explainText_.set (std::move (x));
    }

    const PolicyDefinition::PresentationOptional& PolicyDefinition::
    presentation () const
    {
      return this->presentation_;
    }

    PolicyDefinition::PresentationOptional& PolicyDefinition::
    presentation ()
    {
      return this->presentation_;
    }

    void PolicyDefinition::
    presentation (const PresentationType& x)
    {
      this->presentation_.set (x);
    }

    void PolicyDefinition::
    presentation (const PresentationOptional& x)
    {
      this->presentation_ = x;
    }

    void PolicyDefinition::
    presentation (::std::unique_ptr< PresentationType > x)
    {
      this->presentation_.set (std::move (x));
    }

    const PolicyDefinition::KeyType& PolicyDefinition::
    key () const
    {
      return this->key_.get ();
    }

    PolicyDefinition::KeyType& PolicyDefinition::
    key ()
    {
      return this->key_.get ();
    }

    void PolicyDefinition::
    key (const KeyType& x)
    {
      this->key_.set (x);
    }

    void PolicyDefinition::
    key (::std::unique_ptr< KeyType > x)
    {
      this->key_.set (std::move (x));
    }

    const PolicyDefinition::ValueNameOptional& PolicyDefinition::
    valueName () const
    {
      return this->valueName_;
    }

    PolicyDefinition::ValueNameOptional& PolicyDefinition::
    valueName ()
    {
      return this->valueName_;
    }

    void PolicyDefinition::
    valueName (const ValueNameType& x)
    {
      this->valueName_.set (x);
    }

    void PolicyDefinition::
    valueName (const ValueNameOptional& x)
    {
      this->valueName_ = x;
    }

    void PolicyDefinition::
    valueName (::std::unique_ptr< ValueNameType > x)
    {
      this->valueName_.set (std::move (x));
    }


    // PolicyElements
    // 

    const PolicyElements::BooleanSequence& PolicyElements::
    boolean () const
    {
      return this->boolean_;
    }

    PolicyElements::BooleanSequence& PolicyElements::
    boolean ()
    {
      return this->boolean_;
    }

    void PolicyElements::
    boolean (const BooleanSequence& s)
    {
      this->boolean_ = s;
    }

    const PolicyElements::DecimalSequence& PolicyElements::
    decimal () const
    {
      return this->decimal_;
    }

    PolicyElements::DecimalSequence& PolicyElements::
    decimal ()
    {
      return this->decimal_;
    }

    void PolicyElements::
    decimal (const DecimalSequence& s)
    {
      this->decimal_ = s;
    }

    const PolicyElements::TextSequence& PolicyElements::
    text () const
    {
      return this->text_;
    }

    PolicyElements::TextSequence& PolicyElements::
    text ()
    {
      return this->text_;
    }

    void PolicyElements::
    text (const TextSequence& s)
    {
      this->text_ = s;
    }

    const PolicyElements::EnumSequence& PolicyElements::
    enum_ () const
    {
      return this->enum__;
    }

    PolicyElements::EnumSequence& PolicyElements::
    enum_ ()
    {
      return this->enum__;
    }

    void PolicyElements::
    enum_ (const EnumSequence& s)
    {
      this->enum__ = s;
    }

    const PolicyElements::ListSequence& PolicyElements::
    list () const
    {
      return this->list_;
    }

    PolicyElements::ListSequence& PolicyElements::
    list ()
    {
      return this->list_;
    }

    void PolicyElements::
    list (const ListSequence& s)
    {
      this->list_ = s;
    }

    const PolicyElements::LongDecimalSequence& PolicyElements::
    longDecimal () const
    {
      return this->longDecimal_;
    }

    PolicyElements::LongDecimalSequence& PolicyElements::
    longDecimal ()
    {
      return this->longDecimal_;
    }

    void PolicyElements::
    longDecimal (const LongDecimalSequence& s)
    {
      this->longDecimal_ = s;
    }

    const PolicyElements::MultiTextSequence& PolicyElements::
    multiText () const
    {
      return this->multiText_;
    }

    PolicyElements::MultiTextSequence& PolicyElements::
    multiText ()
    {
      return this->multiText_;
    }

    void PolicyElements::
    multiText (const MultiTextSequence& s)
    {
      this->multiText_ = s;
    }


    // Item
    // 

    const Item::ValueType& Item::
    value () const
    {
      return this->value_.get ();
    }

    Item::ValueType& Item::
    value ()
    {
      return this->value_.get ();
    }

    void Item::
    value (const ValueType& x)
    {
      this->value_.set (x);
    }

    void Item::
    value (::std::unique_ptr< ValueType > x)
    {
      this->value_.set (std::move (x));
    }

    const Item::ValueListOptional& Item::
    valueList () const
    {
      return this->valueList_;
    }

    Item::ValueListOptional& Item::
    valueList ()
    {
      return this->valueList_;
    }

    void Item::
    valueList (const ValueListType& x)
    {
      this->valueList_.set (x);
    }

    void Item::
    valueList (const ValueListOptional& x)
    {
      this->valueList_ = x;
    }

    void Item::
    valueList (::std::unique_ptr< ValueListType > x)
    {
      this->valueList_.set (std::move (x));
    }

    const Item::DisplayNameType& Item::
    displayName () const
    {
      return this->displayName_.get ();
    }

    Item::DisplayNameType& Item::
    displayName ()
    {
      return this->displayName_.get ();
    }

    void Item::
    displayName (const DisplayNameType& x)
    {
      this->displayName_.set (x);
    }

    void Item::
    displayName (::std::unique_ptr< DisplayNameType > x)
    {
      this->displayName_.set (std::move (x));
    }


    // Delete
    // 


    // Decimal
    // 

    const Decimal::ValueType& Decimal::
    value () const
    {
      return this->value_.get ();
    }

    Decimal::ValueType& Decimal::
    value ()
    {
      return this->value_.get ();
    }

    void Decimal::
    value (const ValueType& x)
    {
      this->value_.set (x);
    }


    // LongDecimal
    // 

    const LongDecimal::ValueType& LongDecimal::
    value () const
    {
      return this->value_.get ();
    }

    LongDecimal::ValueType& LongDecimal::
    value ()
    {
      return this->value_.get ();
    }

    void LongDecimal::
    value (const ValueType& x)
    {
      this->value_.set (x);
    }


    // String
    // 
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
    // DecimalElement
    //

    DecimalElement::
    DecimalElement (const IdType& id)
    : ::xml_schema::Type (),
      id_ (id, this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this),
      required_ (required_default_value (), this),
      minValue_ (minValue_default_value (), this),
      maxValue_ (maxValue_default_value (), this),
      storeAsText_ (storeAsText_default_value (), this),
      soft_ (soft_default_value (), this)
    {
    }

    DecimalElement::
    DecimalElement (const DecimalElement& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      clientExtension_ (x.clientExtension_, f, this),
      key_ (x.key_, f, this),
      valueName_ (x.valueName_, f, this),
      required_ (x.required_, f, this),
      minValue_ (x.minValue_, f, this),
      maxValue_ (x.maxValue_, f, this),
      storeAsText_ (x.storeAsText_, f, this),
      soft_ (x.soft_, f, this)
    {
    }

    DecimalElement::
    DecimalElement (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this),
      required_ (this),
      minValue_ (this),
      maxValue_ (this),
      storeAsText_ (this),
      soft_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void DecimalElement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "clientExtension" && n.namespace_ ().empty ())
        {
          this->clientExtension_.set (ClientExtensionTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          this->key_.set (KeyTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "valueName" && n.namespace_ ().empty ())
        {
          this->valueName_.set (ValueNameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "required" && n.namespace_ ().empty ())
        {
          this->required_.set (RequiredTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "minValue" && n.namespace_ ().empty ())
        {
          this->minValue_.set (MinValueTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "maxValue" && n.namespace_ ().empty ())
        {
          this->maxValue_.set (MaxValueTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "storeAsText" && n.namespace_ ().empty ())
        {
          this->storeAsText_.set (StoreAsTextTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "soft" && n.namespace_ ().empty ())
        {
          this->soft_.set (SoftTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!required_.present ())
      {
        this->required_.set (required_default_value ());
      }

      if (!minValue_.present ())
      {
        this->minValue_.set (minValue_default_value ());
      }

      if (!maxValue_.present ())
      {
        this->maxValue_.set (maxValue_default_value ());
      }

      if (!storeAsText_.present ())
      {
        this->storeAsText_.set (storeAsText_default_value ());
      }

      if (!soft_.present ())
      {
        this->soft_.set (soft_default_value ());
      }
    }

    DecimalElement* DecimalElement::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DecimalElement (*this, f, c);
    }

    DecimalElement& DecimalElement::
    operator= (const DecimalElement& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->clientExtension_ = x.clientExtension_;
        this->key_ = x.key_;
        this->valueName_ = x.valueName_;
        this->required_ = x.required_;
        this->minValue_ = x.minValue_;
        this->maxValue_ = x.maxValue_;
        this->storeAsText_ = x.storeAsText_;
        this->soft_ = x.soft_;
      }

      return *this;
    }

    DecimalElement::
    ~DecimalElement ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DecimalElement >
    _xsd_DecimalElement_type_factory_init (
      "DecimalElement",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // LongDecimalElement
    //

    LongDecimalElement::
    LongDecimalElement (const IdType& id)
    : ::xml_schema::Type (),
      id_ (id, this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this),
      required_ (required_default_value (), this),
      minValue_ (minValue_default_value (), this),
      maxValue_ (maxValue_default_value (), this),
      storeAsText_ (storeAsText_default_value (), this),
      soft_ (soft_default_value (), this)
    {
    }

    LongDecimalElement::
    LongDecimalElement (const LongDecimalElement& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      clientExtension_ (x.clientExtension_, f, this),
      key_ (x.key_, f, this),
      valueName_ (x.valueName_, f, this),
      required_ (x.required_, f, this),
      minValue_ (x.minValue_, f, this),
      maxValue_ (x.maxValue_, f, this),
      storeAsText_ (x.storeAsText_, f, this),
      soft_ (x.soft_, f, this)
    {
    }

    LongDecimalElement::
    LongDecimalElement (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this),
      required_ (this),
      minValue_ (this),
      maxValue_ (this),
      storeAsText_ (this),
      soft_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void LongDecimalElement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "clientExtension" && n.namespace_ ().empty ())
        {
          this->clientExtension_.set (ClientExtensionTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          this->key_.set (KeyTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "valueName" && n.namespace_ ().empty ())
        {
          this->valueName_.set (ValueNameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "required" && n.namespace_ ().empty ())
        {
          this->required_.set (RequiredTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "minValue" && n.namespace_ ().empty ())
        {
          this->minValue_.set (MinValueTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "maxValue" && n.namespace_ ().empty ())
        {
          this->maxValue_.set (MaxValueTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "storeAsText" && n.namespace_ ().empty ())
        {
          this->storeAsText_.set (StoreAsTextTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "soft" && n.namespace_ ().empty ())
        {
          this->soft_.set (SoftTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!required_.present ())
      {
        this->required_.set (required_default_value ());
      }

      if (!minValue_.present ())
      {
        this->minValue_.set (minValue_default_value ());
      }

      if (!maxValue_.present ())
      {
        this->maxValue_.set (maxValue_default_value ());
      }

      if (!storeAsText_.present ())
      {
        this->storeAsText_.set (storeAsText_default_value ());
      }

      if (!soft_.present ())
      {
        this->soft_.set (soft_default_value ());
      }
    }

    LongDecimalElement* LongDecimalElement::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class LongDecimalElement (*this, f, c);
    }

    LongDecimalElement& LongDecimalElement::
    operator= (const LongDecimalElement& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->clientExtension_ = x.clientExtension_;
        this->key_ = x.key_;
        this->valueName_ = x.valueName_;
        this->required_ = x.required_;
        this->minValue_ = x.minValue_;
        this->maxValue_ = x.maxValue_;
        this->storeAsText_ = x.storeAsText_;
        this->soft_ = x.soft_;
      }

      return *this;
    }

    LongDecimalElement::
    ~LongDecimalElement ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LongDecimalElement >
    _xsd_LongDecimalElement_type_factory_init (
      "LongDecimalElement",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // BooleanElement
    //

    BooleanElement::
    BooleanElement (const IdType& id)
    : ::xml_schema::Type (),
      trueValue_ (this),
      falseValue_ (this),
      trueList_ (this),
      falseList_ (this),
      id_ (id, this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this)
    {
    }

    BooleanElement::
    BooleanElement (const BooleanElement& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      trueValue_ (x.trueValue_, f, this),
      falseValue_ (x.falseValue_, f, this),
      trueList_ (x.trueList_, f, this),
      falseList_ (x.falseList_, f, this),
      id_ (x.id_, f, this),
      clientExtension_ (x.clientExtension_, f, this),
      key_ (x.key_, f, this),
      valueName_ (x.valueName_, f, this)
    {
    }

    BooleanElement::
    BooleanElement (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      trueValue_ (this),
      falseValue_ (this),
      trueList_ (this),
      falseList_ (this),
      id_ (this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void BooleanElement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // trueValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "trueValue",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< TrueValueType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->trueValue_)
            {
              ::std::unique_ptr< TrueValueType > r (
                dynamic_cast< TrueValueType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->trueValue_.set (::std::move (r));
              continue;
            }
          }
        }

        // falseValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "falseValue",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< FalseValueType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->falseValue_)
            {
              ::std::unique_ptr< FalseValueType > r (
                dynamic_cast< FalseValueType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->falseValue_.set (::std::move (r));
              continue;
            }
          }
        }

        // trueList
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "trueList",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< TrueListType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->trueList_)
            {
              ::std::unique_ptr< TrueListType > r (
                dynamic_cast< TrueListType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->trueList_.set (::std::move (r));
              continue;
            }
          }
        }

        // falseList
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "falseList",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< FalseListType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->falseList_)
            {
              ::std::unique_ptr< FalseListType > r (
                dynamic_cast< FalseListType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->falseList_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "clientExtension" && n.namespace_ ().empty ())
        {
          this->clientExtension_.set (ClientExtensionTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          this->key_.set (KeyTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "valueName" && n.namespace_ ().empty ())
        {
          this->valueName_.set (ValueNameTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    BooleanElement* BooleanElement::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class BooleanElement (*this, f, c);
    }

    BooleanElement& BooleanElement::
    operator= (const BooleanElement& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->trueValue_ = x.trueValue_;
        this->falseValue_ = x.falseValue_;
        this->trueList_ = x.trueList_;
        this->falseList_ = x.falseList_;
        this->id_ = x.id_;
        this->clientExtension_ = x.clientExtension_;
        this->key_ = x.key_;
        this->valueName_ = x.valueName_;
      }

      return *this;
    }

    BooleanElement::
    ~BooleanElement ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, BooleanElement >
    _xsd_BooleanElement_type_factory_init (
      "BooleanElement",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // TextElement
    //

    TextElement::
    TextElement (const IdType& id)
    : ::xml_schema::Type (),
      id_ (id, this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this),
      required_ (required_default_value (), this),
      maxLength_ (maxLength_default_value (), this),
      expandable_ (expandable_default_value (), this),
      soft_ (soft_default_value (), this)
    {
    }

    TextElement::
    TextElement (const TextElement& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      clientExtension_ (x.clientExtension_, f, this),
      key_ (x.key_, f, this),
      valueName_ (x.valueName_, f, this),
      required_ (x.required_, f, this),
      maxLength_ (x.maxLength_, f, this),
      expandable_ (x.expandable_, f, this),
      soft_ (x.soft_, f, this)
    {
    }

    TextElement::
    TextElement (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this),
      required_ (this),
      maxLength_ (this),
      expandable_ (this),
      soft_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void TextElement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "clientExtension" && n.namespace_ ().empty ())
        {
          this->clientExtension_.set (ClientExtensionTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          this->key_.set (KeyTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "valueName" && n.namespace_ ().empty ())
        {
          this->valueName_.set (ValueNameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "required" && n.namespace_ ().empty ())
        {
          this->required_.set (RequiredTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "maxLength" && n.namespace_ ().empty ())
        {
          this->maxLength_.set (MaxLengthTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "expandable" && n.namespace_ ().empty ())
        {
          this->expandable_.set (ExpandableTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "soft" && n.namespace_ ().empty ())
        {
          this->soft_.set (SoftTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!required_.present ())
      {
        this->required_.set (required_default_value ());
      }

      if (!maxLength_.present ())
      {
        this->maxLength_.set (maxLength_default_value ());
      }

      if (!expandable_.present ())
      {
        this->expandable_.set (expandable_default_value ());
      }

      if (!soft_.present ())
      {
        this->soft_.set (soft_default_value ());
      }
    }

    TextElement* TextElement::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TextElement (*this, f, c);
    }

    TextElement& TextElement::
    operator= (const TextElement& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->clientExtension_ = x.clientExtension_;
        this->key_ = x.key_;
        this->valueName_ = x.valueName_;
        this->required_ = x.required_;
        this->maxLength_ = x.maxLength_;
        this->expandable_ = x.expandable_;
        this->soft_ = x.soft_;
      }

      return *this;
    }

    TextElement::
    ~TextElement ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TextElement >
    _xsd_TextElement_type_factory_init (
      "TextElement",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // EnumerationElement
    //

    EnumerationElement::
    EnumerationElement (const IdType& id)
    : ::xml_schema::Type (),
      item_ (this),
      id_ (id, this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this),
      required_ (required_default_value (), this)
    {
    }

    EnumerationElement::
    EnumerationElement (const EnumerationElement& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      item_ (x.item_, f, this),
      id_ (x.id_, f, this),
      clientExtension_ (x.clientExtension_, f, this),
      key_ (x.key_, f, this),
      valueName_ (x.valueName_, f, this),
      required_ (x.required_, f, this)
    {
    }

    EnumerationElement::
    EnumerationElement (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      item_ (this),
      id_ (this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this),
      required_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void EnumerationElement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // item
        //
        if (n.name () == "item" && n.namespace_ () == "http://www.microsoft.com/GroupPolicy/PolicyDefinitions")
        {
          ::std::unique_ptr< ItemType > r (
            ItemTraits::create (i, f, this));

          this->item_.push_back (::std::move (r));
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "clientExtension" && n.namespace_ ().empty ())
        {
          this->clientExtension_.set (ClientExtensionTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          this->key_.set (KeyTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "valueName" && n.namespace_ ().empty ())
        {
          this->valueName_.set (ValueNameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "required" && n.namespace_ ().empty ())
        {
          this->required_.set (RequiredTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!required_.present ())
      {
        this->required_.set (required_default_value ());
      }
    }

    EnumerationElement* EnumerationElement::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class EnumerationElement (*this, f, c);
    }

    EnumerationElement& EnumerationElement::
    operator= (const EnumerationElement& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->item_ = x.item_;
        this->id_ = x.id_;
        this->clientExtension_ = x.clientExtension_;
        this->key_ = x.key_;
        this->valueName_ = x.valueName_;
        this->required_ = x.required_;
      }

      return *this;
    }

    EnumerationElement::
    ~EnumerationElement ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, EnumerationElement >
    _xsd_EnumerationElement_type_factory_init (
      "EnumerationElement",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // ListElement
    //

    ListElement::
    ListElement (const IdType& id)
    : ::xml_schema::Type (),
      id_ (id, this),
      clientExtension_ (this),
      key_ (this),
      valuePrefix_ (this),
      additive_ (additive_default_value (), this),
      expandable_ (expandable_default_value (), this),
      explicitValue_ (explicitValue_default_value (), this)
    {
    }

    ListElement::
    ListElement (const ListElement& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      clientExtension_ (x.clientExtension_, f, this),
      key_ (x.key_, f, this),
      valuePrefix_ (x.valuePrefix_, f, this),
      additive_ (x.additive_, f, this),
      expandable_ (x.expandable_, f, this),
      explicitValue_ (x.explicitValue_, f, this)
    {
    }

    ListElement::
    ListElement (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      clientExtension_ (this),
      key_ (this),
      valuePrefix_ (this),
      additive_ (this),
      expandable_ (this),
      explicitValue_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void ListElement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "clientExtension" && n.namespace_ ().empty ())
        {
          this->clientExtension_.set (ClientExtensionTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          this->key_.set (KeyTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "valuePrefix" && n.namespace_ ().empty ())
        {
          this->valuePrefix_.set (ValuePrefixTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "additive" && n.namespace_ ().empty ())
        {
          this->additive_.set (AdditiveTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "expandable" && n.namespace_ ().empty ())
        {
          this->expandable_.set (ExpandableTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "explicitValue" && n.namespace_ ().empty ())
        {
          this->explicitValue_.set (ExplicitValueTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!additive_.present ())
      {
        this->additive_.set (additive_default_value ());
      }

      if (!expandable_.present ())
      {
        this->expandable_.set (expandable_default_value ());
      }

      if (!explicitValue_.present ())
      {
        this->explicitValue_.set (explicitValue_default_value ());
      }
    }

    ListElement* ListElement::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ListElement (*this, f, c);
    }

    ListElement& ListElement::
    operator= (const ListElement& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->clientExtension_ = x.clientExtension_;
        this->key_ = x.key_;
        this->valuePrefix_ = x.valuePrefix_;
        this->additive_ = x.additive_;
        this->expandable_ = x.expandable_;
        this->explicitValue_ = x.explicitValue_;
      }

      return *this;
    }

    ListElement::
    ~ListElement ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ListElement >
    _xsd_ListElement_type_factory_init (
      "ListElement",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // Value
    //

    Value::
    Value ()
    : ::xml_schema::Type (),
      delete__ (this),
      decimal_ (this),
      longDecimal_ (this),
      string_ (this)
    {
    }

    Value::
    Value (const Value& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      delete__ (x.delete__, f, this),
      decimal_ (x.decimal_, f, this),
      longDecimal_ (x.longDecimal_, f, this),
      string_ (x.string_, f, this)
    {
    }

    Value::
    Value (const ::xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      delete__ (this),
      decimal_ (this),
      longDecimal_ (this),
      string_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void Value::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // delete
        //
        if (n.name () == "delete" && n.namespace_ () == "http://www.microsoft.com/GroupPolicy/PolicyDefinitions")
        {
          ::std::unique_ptr< DeleteType > r (
            DeleteTraits::create (i, f, this));

          if (!this->delete__)
          {
            this->delete__.set (::std::move (r));
            continue;
          }
        }

        // decimal
        //
        if (n.name () == "decimal" && n.namespace_ () == "http://www.microsoft.com/GroupPolicy/PolicyDefinitions")
        {
          ::std::unique_ptr< DecimalType > r (
            DecimalTraits::create (i, f, this));

          if (!this->decimal_)
          {
            this->decimal_.set (::std::move (r));
            continue;
          }
        }

        // longDecimal
        //
        if (n.name () == "longDecimal" && n.namespace_ () == "http://www.microsoft.com/GroupPolicy/PolicyDefinitions")
        {
          ::std::unique_ptr< LongDecimalType > r (
            LongDecimalTraits::create (i, f, this));

          if (!this->longDecimal_)
          {
            this->longDecimal_.set (::std::move (r));
            continue;
          }
        }

        // string
        //
        if (n.name () == "string" && n.namespace_ () == "http://www.microsoft.com/GroupPolicy/PolicyDefinitions")
        {
          ::std::unique_ptr< StringType > r (
            StringTraits::create (i, f, this));

          if (!this->string_)
          {
            this->string_.set (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    Value* Value::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Value (*this, f, c);
    }

    Value& Value::
    operator= (const Value& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->delete__ = x.delete__;
        this->decimal_ = x.decimal_;
        this->longDecimal_ = x.longDecimal_;
        this->string_ = x.string_;
      }

      return *this;
    }

    Value::
    ~Value ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, Value >
    _xsd_Value_type_factory_init (
      "Value",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // ValueList
    //

    ValueList::
    ValueList ()
    : ::xml_schema::Type (),
      item_ (this),
      defaultKey_ (this)
    {
    }

    ValueList::
    ValueList (const ValueList& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      item_ (x.item_, f, this),
      defaultKey_ (x.defaultKey_, f, this)
    {
    }

    ValueList::
    ValueList (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      item_ (this),
      defaultKey_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ValueList::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // item
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "item",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ItemType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ItemType > r (
              dynamic_cast< ItemType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->item_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "defaultKey" && n.namespace_ ().empty ())
        {
          this->defaultKey_.set (DefaultKeyTraits::create (i, f, this));
          continue;
        }
      }
    }

    ValueList* ValueList::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ValueList (*this, f, c);
    }

    ValueList& ValueList::
    operator= (const ValueList& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->item_ = x.item_;
        this->defaultKey_ = x.defaultKey_;
      }

      return *this;
    }

    ValueList::
    ~ValueList ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ValueList >
    _xsd_ValueList_type_factory_init (
      "ValueList",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // ValueItem
    //

    ValueItem::
    ValueItem (const ValueType& value,
               const ValueNameType& valueName)
    : ::xml_schema::Type (),
      value_ (value, this),
      key_ (this),
      valueName_ (valueName, this)
    {
    }

    ValueItem::
    ValueItem (::std::unique_ptr< ValueType > value,
               const ValueNameType& valueName)
    : ::xml_schema::Type (),
      value_ (std::move (value), this),
      key_ (this),
      valueName_ (valueName, this)
    {
    }

    ValueItem::
    ValueItem (const ValueItem& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      value_ (x.value_, f, this),
      key_ (x.key_, f, this),
      valueName_ (x.valueName_, f, this)
    {
    }

    ValueItem::
    ValueItem (const ::xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      value_ (this),
      key_ (this),
      valueName_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ValueItem::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // value
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "value",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ValueType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!value_.present ())
            {
              ::std::unique_ptr< ValueType > r (
                dynamic_cast< ValueType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->value_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "value",
          "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          this->key_.set (KeyTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "valueName" && n.namespace_ ().empty ())
        {
          this->valueName_.set (ValueNameTraits::create (i, f, this));
          continue;
        }
      }

      if (!valueName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "valueName",
          "");
      }
    }

    ValueItem* ValueItem::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ValueItem (*this, f, c);
    }

    ValueItem& ValueItem::
    operator= (const ValueItem& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->value_ = x.value_;
        this->key_ = x.key_;
        this->valueName_ = x.valueName_;
      }

      return *this;
    }

    ValueItem::
    ~ValueItem ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ValueItem >
    _xsd_ValueItem_type_factory_init (
      "ValueItem",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // MultiTextElement
    //

    MultiTextElement::
    MultiTextElement (const IdType& id)
    : ::xml_schema::Type (),
      id_ (id, this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this),
      required_ (required_default_value (), this),
      maxLength_ (maxLength_default_value (), this),
      maxStrings_ (maxStrings_default_value (), this),
      soft_ (soft_default_value (), this)
    {
    }

    MultiTextElement::
    MultiTextElement (const MultiTextElement& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      id_ (x.id_, f, this),
      clientExtension_ (x.clientExtension_, f, this),
      key_ (x.key_, f, this),
      valueName_ (x.valueName_, f, this),
      required_ (x.required_, f, this),
      maxLength_ (x.maxLength_, f, this),
      maxStrings_ (x.maxStrings_, f, this),
      soft_ (x.soft_, f, this)
    {
    }

    MultiTextElement::
    MultiTextElement (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      id_ (this),
      clientExtension_ (this),
      key_ (this),
      valueName_ (this),
      required_ (this),
      maxLength_ (this),
      maxStrings_ (this),
      soft_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MultiTextElement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "clientExtension" && n.namespace_ ().empty ())
        {
          this->clientExtension_.set (ClientExtensionTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          this->key_.set (KeyTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "valueName" && n.namespace_ ().empty ())
        {
          this->valueName_.set (ValueNameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "required" && n.namespace_ ().empty ())
        {
          this->required_.set (RequiredTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "maxLength" && n.namespace_ ().empty ())
        {
          this->maxLength_.set (MaxLengthTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "maxStrings" && n.namespace_ ().empty ())
        {
          this->maxStrings_.set (MaxStringsTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "soft" && n.namespace_ ().empty ())
        {
          this->soft_.set (SoftTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }

      if (!required_.present ())
      {
        this->required_.set (required_default_value ());
      }

      if (!maxLength_.present ())
      {
        this->maxLength_.set (maxLength_default_value ());
      }

      if (!maxStrings_.present ())
      {
        this->maxStrings_.set (maxStrings_default_value ());
      }

      if (!soft_.present ())
      {
        this->soft_.set (soft_default_value ());
      }
    }

    MultiTextElement* MultiTextElement::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class MultiTextElement (*this, f, c);
    }

    MultiTextElement& MultiTextElement::
    operator= (const MultiTextElement& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->id_ = x.id_;
        this->clientExtension_ = x.clientExtension_;
        this->key_ = x.key_;
        this->valueName_ = x.valueName_;
        this->required_ = x.required_;
        this->maxLength_ = x.maxLength_;
        this->maxStrings_ = x.maxStrings_;
        this->soft_ = x.soft_;
      }

      return *this;
    }

    MultiTextElement::
    ~MultiTextElement ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MultiTextElement >
    _xsd_MultiTextElement_type_factory_init (
      "multiTextElement",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // DataElementContent
    //

    DataElementContent::
    DataElementContent (const RefIdType& refId)
    : ::xml_schema::String (),
      refId_ (refId, this)
    {
    }

    DataElementContent::
    DataElementContent (const char* _xsd_String_base,
                        const RefIdType& refId)
    : ::xml_schema::String (_xsd_String_base),
      refId_ (refId, this)
    {
    }

    DataElementContent::
    DataElementContent (const ::std::string& _xsd_String_base,
                        const RefIdType& refId)
    : ::xml_schema::String (_xsd_String_base),
      refId_ (refId, this)
    {
    }

    DataElementContent::
    DataElementContent (const ::xml_schema::String& _xsd_String_base,
                        const RefIdType& refId)
    : ::xml_schema::String (_xsd_String_base),
      refId_ (refId, this)
    {
    }

    DataElementContent::
    DataElementContent (const DataElementContent& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c),
      refId_ (x.refId_, f, this)
    {
    }

    DataElementContent::
    DataElementContent (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
      refId_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void DataElementContent::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "refId" && n.namespace_ ().empty ())
        {
          this->refId_.set (RefIdTraits::create (i, f, this));
          continue;
        }
      }

      if (!refId_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "refId",
          "");
      }
    }

    DataElementContent& DataElementContent::
    operator= (const DataElementContent& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::String& > (*this) = x;
        this->refId_ = x.refId_;
      }

      return *this;
    }

    DataElementContent::
    ~DataElementContent ()
    {
    }

    // DataElement
    //

    DataElement::
    DataElement (const RefIdType& refId)
    : ::xml_schema::Type (),
      refId_ (refId, this)
    {
    }

    DataElement::
    DataElement (const DataElement& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      refId_ (x.refId_, f, this)
    {
    }

    DataElement::
    DataElement (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      refId_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void DataElement::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "refId" && n.namespace_ ().empty ())
        {
          this->refId_.set (RefIdTraits::create (i, f, this));
          continue;
        }
      }

      if (!refId_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "refId",
          "");
      }
    }

    DataElement& DataElement::
    operator= (const DataElement& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->refId_ = x.refId_;
      }

      return *this;
    }

    DataElement::
    ~DataElement ()
    {
    }

    // DecimalTextBox
    //

    DecimalTextBox::
    DecimalTextBox (const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (refId),
      defaultValue_ (defaultValue_default_value (), this),
      spin_ (spin_default_value (), this),
      spinStep_ (spinStep_default_value (), this)
    {
    }

    DecimalTextBox::
    DecimalTextBox (const char* _xsd_String_base,
                    const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      defaultValue_ (defaultValue_default_value (), this),
      spin_ (spin_default_value (), this),
      spinStep_ (spinStep_default_value (), this)
    {
    }

    DecimalTextBox::
    DecimalTextBox (const ::std::string& _xsd_String_base,
                    const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      defaultValue_ (defaultValue_default_value (), this),
      spin_ (spin_default_value (), this),
      spinStep_ (spinStep_default_value (), this)
    {
    }

    DecimalTextBox::
    DecimalTextBox (const ::xml_schema::String& _xsd_String_base,
                    const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      defaultValue_ (defaultValue_default_value (), this),
      spin_ (spin_default_value (), this),
      spinStep_ (spinStep_default_value (), this)
    {
    }

    DecimalTextBox::
    DecimalTextBox (const DecimalTextBox& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (x, f, c),
      defaultValue_ (x.defaultValue_, f, this),
      spin_ (x.spin_, f, this),
      spinStep_ (x.spinStep_, f, this)
    {
    }

    DecimalTextBox::
    DecimalTextBox (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (e, f | ::xml_schema::Flags::base, c),
      defaultValue_ (this),
      spin_ (this),
      spinStep_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void DecimalTextBox::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::GroupPolicy::PolicyDefinitions::DataElementContent::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "defaultValue" && n.namespace_ ().empty ())
        {
          this->defaultValue_.set (DefaultValueTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "spin" && n.namespace_ ().empty ())
        {
          this->spin_.set (SpinTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "spinStep" && n.namespace_ ().empty ())
        {
          this->spinStep_.set (SpinStepTraits::create (i, f, this));
          continue;
        }
      }

      if (!defaultValue_.present ())
      {
        this->defaultValue_.set (defaultValue_default_value ());
      }

      if (!spin_.present ())
      {
        this->spin_.set (spin_default_value ());
      }

      if (!spinStep_.present ())
      {
        this->spinStep_.set (spinStep_default_value ());
      }
    }

    DecimalTextBox* DecimalTextBox::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DecimalTextBox (*this, f, c);
    }

    DecimalTextBox& DecimalTextBox::
    operator= (const DecimalTextBox& x)
    {
      if (this != &x)
      {
        static_cast< ::GroupPolicy::PolicyDefinitions::DataElementContent& > (*this) = x;
        this->defaultValue_ = x.defaultValue_;
        this->spin_ = x.spin_;
        this->spinStep_ = x.spinStep_;
      }

      return *this;
    }

    DecimalTextBox::
    ~DecimalTextBox ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DecimalTextBox >
    _xsd_DecimalTextBox_type_factory_init (
      "DecimalTextBox",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // LongDecimalTextBox
    //

    LongDecimalTextBox::
    LongDecimalTextBox (const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (refId),
      defaultValue_ (defaultValue_default_value (), this),
      spin_ (spin_default_value (), this),
      spinStep_ (spinStep_default_value (), this)
    {
    }

    LongDecimalTextBox::
    LongDecimalTextBox (const char* _xsd_String_base,
                        const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      defaultValue_ (defaultValue_default_value (), this),
      spin_ (spin_default_value (), this),
      spinStep_ (spinStep_default_value (), this)
    {
    }

    LongDecimalTextBox::
    LongDecimalTextBox (const ::std::string& _xsd_String_base,
                        const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      defaultValue_ (defaultValue_default_value (), this),
      spin_ (spin_default_value (), this),
      spinStep_ (spinStep_default_value (), this)
    {
    }

    LongDecimalTextBox::
    LongDecimalTextBox (const ::xml_schema::String& _xsd_String_base,
                        const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      defaultValue_ (defaultValue_default_value (), this),
      spin_ (spin_default_value (), this),
      spinStep_ (spinStep_default_value (), this)
    {
    }

    LongDecimalTextBox::
    LongDecimalTextBox (const LongDecimalTextBox& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (x, f, c),
      defaultValue_ (x.defaultValue_, f, this),
      spin_ (x.spin_, f, this),
      spinStep_ (x.spinStep_, f, this)
    {
    }

    LongDecimalTextBox::
    LongDecimalTextBox (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (e, f | ::xml_schema::Flags::base, c),
      defaultValue_ (this),
      spin_ (this),
      spinStep_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void LongDecimalTextBox::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::GroupPolicy::PolicyDefinitions::DataElementContent::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "defaultValue" && n.namespace_ ().empty ())
        {
          this->defaultValue_.set (DefaultValueTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "spin" && n.namespace_ ().empty ())
        {
          this->spin_.set (SpinTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "spinStep" && n.namespace_ ().empty ())
        {
          this->spinStep_.set (SpinStepTraits::create (i, f, this));
          continue;
        }
      }

      if (!defaultValue_.present ())
      {
        this->defaultValue_.set (defaultValue_default_value ());
      }

      if (!spin_.present ())
      {
        this->spin_.set (spin_default_value ());
      }

      if (!spinStep_.present ())
      {
        this->spinStep_.set (spinStep_default_value ());
      }
    }

    LongDecimalTextBox* LongDecimalTextBox::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class LongDecimalTextBox (*this, f, c);
    }

    LongDecimalTextBox& LongDecimalTextBox::
    operator= (const LongDecimalTextBox& x)
    {
      if (this != &x)
      {
        static_cast< ::GroupPolicy::PolicyDefinitions::DataElementContent& > (*this) = x;
        this->defaultValue_ = x.defaultValue_;
        this->spin_ = x.spin_;
        this->spinStep_ = x.spinStep_;
      }

      return *this;
    }

    LongDecimalTextBox::
    ~LongDecimalTextBox ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LongDecimalTextBox >
    _xsd_LongDecimalTextBox_type_factory_init (
      "LongDecimalTextBox",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // TextBox
    //

    TextBox::
    TextBox (const RefIdType& refId,
             const LabelType& label)
    : ::GroupPolicy::PolicyDefinitions::DataElement (refId),
      label_ (label, this),
      defaultValue_ (this)
    {
    }

    TextBox::
    TextBox (const RefIdType& refId,
             ::std::unique_ptr< LabelType > label)
    : ::GroupPolicy::PolicyDefinitions::DataElement (refId),
      label_ (std::move (label), this),
      defaultValue_ (this)
    {
    }

    TextBox::
    TextBox (const TextBox& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElement (x, f, c),
      label_ (x.label_, f, this),
      defaultValue_ (x.defaultValue_, f, this)
    {
    }

    TextBox::
    TextBox (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElement (e, f | ::xml_schema::Flags::base, c),
      label_ (this),
      defaultValue_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void TextBox::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::GroupPolicy::PolicyDefinitions::DataElement::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // label
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "label",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< LabelType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!label_.present ())
            {
              ::std::unique_ptr< LabelType > r (
                dynamic_cast< LabelType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->label_.set (::std::move (r));
              continue;
            }
          }
        }

        // defaultValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "defaultValue",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< DefaultValueType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->defaultValue_)
            {
              ::std::unique_ptr< DefaultValueType > r (
                dynamic_cast< DefaultValueType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->defaultValue_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!label_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "label",
          "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");
      }
    }

    TextBox* TextBox::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class TextBox (*this, f, c);
    }

    TextBox& TextBox::
    operator= (const TextBox& x)
    {
      if (this != &x)
      {
        static_cast< ::GroupPolicy::PolicyDefinitions::DataElement& > (*this) = x;
        this->label_ = x.label_;
        this->defaultValue_ = x.defaultValue_;
      }

      return *this;
    }

    TextBox::
    ~TextBox ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, TextBox >
    _xsd_TextBox_type_factory_init (
      "TextBox",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // MultiTextBox
    //

    MultiTextBox::
    MultiTextBox (const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElement (refId),
      showAsDialog_ (showAsDialog_default_value (), this),
      defaultHeight_ (defaultHeight_default_value (), this)
    {
    }

    MultiTextBox::
    MultiTextBox (const MultiTextBox& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElement (x, f, c),
      showAsDialog_ (x.showAsDialog_, f, this),
      defaultHeight_ (x.defaultHeight_, f, this)
    {
    }

    MultiTextBox::
    MultiTextBox (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElement (e, f | ::xml_schema::Flags::base, c),
      showAsDialog_ (this),
      defaultHeight_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void MultiTextBox::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::GroupPolicy::PolicyDefinitions::DataElement::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "showAsDialog" && n.namespace_ ().empty ())
        {
          this->showAsDialog_.set (ShowAsDialogTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "defaultHeight" && n.namespace_ ().empty ())
        {
          this->defaultHeight_.set (DefaultHeightTraits::create (i, f, this));
          continue;
        }
      }

      if (!showAsDialog_.present ())
      {
        this->showAsDialog_.set (showAsDialog_default_value ());
      }

      if (!defaultHeight_.present ())
      {
        this->defaultHeight_.set (defaultHeight_default_value ());
      }
    }

    MultiTextBox* MultiTextBox::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class MultiTextBox (*this, f, c);
    }

    MultiTextBox& MultiTextBox::
    operator= (const MultiTextBox& x)
    {
      if (this != &x)
      {
        static_cast< ::GroupPolicy::PolicyDefinitions::DataElement& > (*this) = x;
        this->showAsDialog_ = x.showAsDialog_;
        this->defaultHeight_ = x.defaultHeight_;
      }

      return *this;
    }

    MultiTextBox::
    ~MultiTextBox ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, MultiTextBox >
    _xsd_MultiTextBox_type_factory_init (
      "MultiTextBox",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // CheckBox
    //

    CheckBox::
    CheckBox (const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (refId),
      defaultChecked_ (defaultChecked_default_value (), this)
    {
    }

    CheckBox::
    CheckBox (const char* _xsd_String_base,
              const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      defaultChecked_ (defaultChecked_default_value (), this)
    {
    }

    CheckBox::
    CheckBox (const ::std::string& _xsd_String_base,
              const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      defaultChecked_ (defaultChecked_default_value (), this)
    {
    }

    CheckBox::
    CheckBox (const ::xml_schema::String& _xsd_String_base,
              const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      defaultChecked_ (defaultChecked_default_value (), this)
    {
    }

    CheckBox::
    CheckBox (const CheckBox& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (x, f, c),
      defaultChecked_ (x.defaultChecked_, f, this)
    {
    }

    CheckBox::
    CheckBox (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (e, f | ::xml_schema::Flags::base, c),
      defaultChecked_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void CheckBox::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::GroupPolicy::PolicyDefinitions::DataElementContent::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "defaultChecked" && n.namespace_ ().empty ())
        {
          this->defaultChecked_.set (DefaultCheckedTraits::create (i, f, this));
          continue;
        }
      }

      if (!defaultChecked_.present ())
      {
        this->defaultChecked_.set (defaultChecked_default_value ());
      }
    }

    CheckBox* CheckBox::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CheckBox (*this, f, c);
    }

    CheckBox& CheckBox::
    operator= (const CheckBox& x)
    {
      if (this != &x)
      {
        static_cast< ::GroupPolicy::PolicyDefinitions::DataElementContent& > (*this) = x;
        this->defaultChecked_ = x.defaultChecked_;
      }

      return *this;
    }

    CheckBox::
    ~CheckBox ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CheckBox >
    _xsd_CheckBox_type_factory_init (
      "CheckBox",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // ComboBox
    //

    ComboBox::
    ComboBox (const RefIdType& refId,
              const LabelType& label)
    : ::GroupPolicy::PolicyDefinitions::DataElement (refId),
      label_ (label, this),
      default__ (this),
      suggestion_ (this),
      noSort_ (noSort_default_value (), this)
    {
    }

    ComboBox::
    ComboBox (const RefIdType& refId,
              ::std::unique_ptr< LabelType > label)
    : ::GroupPolicy::PolicyDefinitions::DataElement (refId),
      label_ (std::move (label), this),
      default__ (this),
      suggestion_ (this),
      noSort_ (noSort_default_value (), this)
    {
    }

    ComboBox::
    ComboBox (const ComboBox& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElement (x, f, c),
      label_ (x.label_, f, this),
      default__ (x.default__, f, this),
      suggestion_ (x.suggestion_, f, this),
      noSort_ (x.noSort_, f, this)
    {
    }

    ComboBox::
    ComboBox (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElement (e, f | ::xml_schema::Flags::base, c),
      label_ (this),
      default__ (this),
      suggestion_ (this),
      noSort_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void ComboBox::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::GroupPolicy::PolicyDefinitions::DataElement::parse (p, f);

      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // label
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "label",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< LabelType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!label_.present ())
            {
              ::std::unique_ptr< LabelType > r (
                dynamic_cast< LabelType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->label_.set (::std::move (r));
              continue;
            }
          }
        }

        // default
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "default",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< DefaultType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->default__)
            {
              ::std::unique_ptr< DefaultType > r (
                dynamic_cast< DefaultType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->default__.set (::std::move (r));
              continue;
            }
          }
        }

        // suggestion
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "suggestion",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< SuggestionType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< SuggestionType > r (
              dynamic_cast< SuggestionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->suggestion_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      if (!label_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "label",
          "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "noSort" && n.namespace_ ().empty ())
        {
          this->noSort_.set (NoSortTraits::create (i, f, this));
          continue;
        }
      }

      if (!noSort_.present ())
      {
        this->noSort_.set (noSort_default_value ());
      }
    }

    ComboBox* ComboBox::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ComboBox (*this, f, c);
    }

    ComboBox& ComboBox::
    operator= (const ComboBox& x)
    {
      if (this != &x)
      {
        static_cast< ::GroupPolicy::PolicyDefinitions::DataElement& > (*this) = x;
        this->label_ = x.label_;
        this->default__ = x.default__;
        this->suggestion_ = x.suggestion_;
        this->noSort_ = x.noSort_;
      }

      return *this;
    }

    ComboBox::
    ~ComboBox ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ComboBox >
    _xsd_ComboBox_type_factory_init (
      "ComboBox",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // DropdownList
    //

    DropdownList::
    DropdownList (const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (refId),
      noSort_ (noSort_default_value (), this),
      defaultItem_ (this)
    {
    }

    DropdownList::
    DropdownList (const char* _xsd_String_base,
                  const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      noSort_ (noSort_default_value (), this),
      defaultItem_ (this)
    {
    }

    DropdownList::
    DropdownList (const ::std::string& _xsd_String_base,
                  const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      noSort_ (noSort_default_value (), this),
      defaultItem_ (this)
    {
    }

    DropdownList::
    DropdownList (const ::xml_schema::String& _xsd_String_base,
                  const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId),
      noSort_ (noSort_default_value (), this),
      defaultItem_ (this)
    {
    }

    DropdownList::
    DropdownList (const DropdownList& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (x, f, c),
      noSort_ (x.noSort_, f, this),
      defaultItem_ (x.defaultItem_, f, this)
    {
    }

    DropdownList::
    DropdownList (const ::xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (e, f | ::xml_schema::Flags::base, c),
      noSort_ (this),
      defaultItem_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void DropdownList::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      this->::GroupPolicy::PolicyDefinitions::DataElementContent::parse (p, f);

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "noSort" && n.namespace_ ().empty ())
        {
          this->noSort_.set (NoSortTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "defaultItem" && n.namespace_ ().empty ())
        {
          this->defaultItem_.set (DefaultItemTraits::create (i, f, this));
          continue;
        }
      }

      if (!noSort_.present ())
      {
        this->noSort_.set (noSort_default_value ());
      }
    }

    DropdownList* DropdownList::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class DropdownList (*this, f, c);
    }

    DropdownList& DropdownList::
    operator= (const DropdownList& x)
    {
      if (this != &x)
      {
        static_cast< ::GroupPolicy::PolicyDefinitions::DataElementContent& > (*this) = x;
        this->noSort_ = x.noSort_;
        this->defaultItem_ = x.defaultItem_;
      }

      return *this;
    }

    DropdownList::
    ~DropdownList ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, DropdownList >
    _xsd_DropdownList_type_factory_init (
      "DropdownList",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // ListBox
    //

    ListBox::
    ListBox (const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (refId)
    {
    }

    ListBox::
    ListBox (const char* _xsd_String_base,
             const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId)
    {
    }

    ListBox::
    ListBox (const ::std::string& _xsd_String_base,
             const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId)
    {
    }

    ListBox::
    ListBox (const ::xml_schema::String& _xsd_String_base,
             const RefIdType& refId)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (_xsd_String_base,
                                                            refId)
    {
    }

    ListBox::
    ListBox (const ListBox& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (x, f, c)
    {
    }

    ListBox::
    ListBox (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::GroupPolicy::PolicyDefinitions::DataElementContent (e, f, c)
    {
    }

    ListBox* ListBox::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ListBox (*this, f, c);
    }

    ListBox::
    ~ListBox ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ListBox >
    _xsd_ListBox_type_factory_init (
      "ListBox",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // PolicyPresentation
    //

    PolicyPresentation::
    PolicyPresentation (const IdType& id)
    : ::xml_schema::Type (),
      text_ (this),
      decimalTextBox_ (this),
      textBox_ (this),
      checkBox_ (this),
      comboBox_ (this),
      dropdownList_ (this),
      listBox_ (this),
      longDecimalTextBox_ (this),
      multiTextBox_ (this),
      id_ (id, this)
    {
    }

    PolicyPresentation::
    PolicyPresentation (const PolicyPresentation& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      text_ (x.text_, f, this),
      decimalTextBox_ (x.decimalTextBox_, f, this),
      textBox_ (x.textBox_, f, this),
      checkBox_ (x.checkBox_, f, this),
      comboBox_ (x.comboBox_, f, this),
      dropdownList_ (x.dropdownList_, f, this),
      listBox_ (x.listBox_, f, this),
      longDecimalTextBox_ (x.longDecimalTextBox_, f, this),
      multiTextBox_ (x.multiTextBox_, f, this),
      id_ (x.id_, f, this)
    {
    }

    PolicyPresentation::
    PolicyPresentation (const ::xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      text_ (this),
      decimalTextBox_ (this),
      textBox_ (this),
      checkBox_ (this),
      comboBox_ (this),
      dropdownList_ (this),
      listBox_ (this),
      longDecimalTextBox_ (this),
      multiTextBox_ (this),
      id_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PolicyPresentation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // text
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "text",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< TextType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< TextType > r (
              dynamic_cast< TextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->text_.push_back (::std::move (r));
            continue;
          }
        }

        // decimalTextBox
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "decimalTextBox",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< DecimalTextBoxType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< DecimalTextBoxType > r (
              dynamic_cast< DecimalTextBoxType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->decimalTextBox_.push_back (::std::move (r));
            continue;
          }
        }

        // textBox
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "textBox",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< TextBoxType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< TextBoxType > r (
              dynamic_cast< TextBoxType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->textBox_.push_back (::std::move (r));
            continue;
          }
        }

        // checkBox
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "checkBox",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< CheckBoxType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< CheckBoxType > r (
              dynamic_cast< CheckBoxType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->checkBox_.push_back (::std::move (r));
            continue;
          }
        }

        // comboBox
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "comboBox",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ComboBoxType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ComboBoxType > r (
              dynamic_cast< ComboBoxType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->comboBox_.push_back (::std::move (r));
            continue;
          }
        }

        // dropdownList
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "dropdownList",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< DropdownListType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< DropdownListType > r (
              dynamic_cast< DropdownListType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->dropdownList_.push_back (::std::move (r));
            continue;
          }
        }

        // listBox
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "listBox",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ListBoxType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ListBoxType > r (
              dynamic_cast< ListBoxType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->listBox_.push_back (::std::move (r));
            continue;
          }
        }

        // longDecimalTextBox
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "longDecimalTextBox",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< LongDecimalTextBoxType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< LongDecimalTextBoxType > r (
              dynamic_cast< LongDecimalTextBoxType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->longDecimalTextBox_.push_back (::std::move (r));
            continue;
          }
        }

        // multiTextBox
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "multiTextBox",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< MultiTextBoxType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< MultiTextBoxType > r (
              dynamic_cast< MultiTextBoxType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->multiTextBox_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    PolicyPresentation* PolicyPresentation::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PolicyPresentation (*this, f, c);
    }

    PolicyPresentation& PolicyPresentation::
    operator= (const PolicyPresentation& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->text_ = x.text_;
        this->decimalTextBox_ = x.decimalTextBox_;
        this->textBox_ = x.textBox_;
        this->checkBox_ = x.checkBox_;
        this->comboBox_ = x.comboBox_;
        this->dropdownList_ = x.dropdownList_;
        this->listBox_ = x.listBox_;
        this->longDecimalTextBox_ = x.longDecimalTextBox_;
        this->multiTextBox_ = x.multiTextBox_;
        this->id_ = x.id_;
      }

      return *this;
    }

    PolicyPresentation::
    ~PolicyPresentation ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PolicyPresentation >
    _xsd_PolicyPresentation_type_factory_init (
      "PolicyPresentation",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // CategoryReference
    //

    CategoryReference::
    CategoryReference (const RefType& ref)
    : ::xml_schema::Type (),
      ref_ (ref, this)
    {
    }

    CategoryReference::
    CategoryReference (const CategoryReference& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ref_ (x.ref_, f, this)
    {
    }

    CategoryReference::
    CategoryReference (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ref_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void CategoryReference::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ref" && n.namespace_ ().empty ())
        {
          this->ref_.set (RefTraits::create (i, f, this));
          continue;
        }
      }

      if (!ref_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ref",
          "");
      }
    }

    CategoryReference* CategoryReference::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class CategoryReference (*this, f, c);
    }

    CategoryReference& CategoryReference::
    operator= (const CategoryReference& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->ref_ = x.ref_;
      }

      return *this;
    }

    CategoryReference::
    ~CategoryReference ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, CategoryReference >
    _xsd_CategoryReference_type_factory_init (
      "CategoryReference",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // Category
    //

    Category::
    Category (const NameType& name,
              const DisplayNameType& displayName)
    : ::xml_schema::Type (),
      annotation_ (this),
      parentCategory_ (this),
      seeAlso_ (this),
      keywords_ (this),
      name_ (name, this),
      displayName_ (displayName, this),
      explainText_ (this)
    {
    }

    Category::
    Category (const Category& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      annotation_ (x.annotation_, f, this),
      parentCategory_ (x.parentCategory_, f, this),
      seeAlso_ (x.seeAlso_, f, this),
      keywords_ (x.keywords_, f, this),
      name_ (x.name_, f, this),
      displayName_ (x.displayName_, f, this),
      explainText_ (x.explainText_, f, this)
    {
    }

    Category::
    Category (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      annotation_ (this),
      parentCategory_ (this),
      seeAlso_ (this),
      keywords_ (this),
      name_ (this),
      displayName_ (this),
      explainText_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Category::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // annotation
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "annotation",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< AnnotationType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< AnnotationType > r (
              dynamic_cast< AnnotationType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->annotation_.push_back (::std::move (r));
            continue;
          }
        }

        // parentCategory
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "parentCategory",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ParentCategoryType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->parentCategory_)
            {
              ::std::unique_ptr< ParentCategoryType > r (
                dynamic_cast< ParentCategoryType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->parentCategory_.set (::std::move (r));
              continue;
            }
          }
        }

        // seeAlso
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "seeAlso",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< SeeAlsoType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< SeeAlsoType > r (
              dynamic_cast< SeeAlsoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->seeAlso_.push_back (::std::move (r));
            continue;
          }
        }

        // keywords
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "keywords",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< KeywordsType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->keywords_)
            {
              ::std::unique_ptr< KeywordsType > r (
                dynamic_cast< KeywordsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->keywords_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "displayName" && n.namespace_ ().empty ())
        {
          this->displayName_.set (DisplayNameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "explainText" && n.namespace_ ().empty ())
        {
          this->explainText_.set (ExplainTextTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!displayName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "displayName",
          "");
      }
    }

    Category* Category::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Category (*this, f, c);
    }

    Category& Category::
    operator= (const Category& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->annotation_ = x.annotation_;
        this->parentCategory_ = x.parentCategory_;
        this->seeAlso_ = x.seeAlso_;
        this->keywords_ = x.keywords_;
        this->name_ = x.name_;
        this->displayName_ = x.displayName_;
        this->explainText_ = x.explainText_;
      }

      return *this;
    }

    Category::
    ~Category ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, Category >
    _xsd_Category_type_factory_init (
      "Category",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // SupportedProducts
    //

    SupportedProducts::
    SupportedProducts ()
    : ::xml_schema::Type (),
      product_ (this)
    {
    }

    SupportedProducts::
    SupportedProducts (const SupportedProducts& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      product_ (x.product_, f, this)
    {
    }

    SupportedProducts::
    SupportedProducts (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      product_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SupportedProducts::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // product
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "product",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ProductType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ProductType > r (
              dynamic_cast< ProductType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->product_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SupportedProducts* SupportedProducts::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SupportedProducts (*this, f, c);
    }

    SupportedProducts& SupportedProducts::
    operator= (const SupportedProducts& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->product_ = x.product_;
      }

      return *this;
    }

    SupportedProducts::
    ~SupportedProducts ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportedProducts >
    _xsd_SupportedProducts_type_factory_init (
      "SupportedProducts",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // SupportedProduct
    //

    SupportedProduct::
    SupportedProduct (const NameType& name,
                      const DisplayNameType& displayName)
    : ::xml_schema::Type (),
      majorVersion_ (this),
      name_ (name, this),
      displayName_ (displayName, this)
    {
    }

    SupportedProduct::
    SupportedProduct (const SupportedProduct& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      majorVersion_ (x.majorVersion_, f, this),
      name_ (x.name_, f, this),
      displayName_ (x.displayName_, f, this)
    {
    }

    SupportedProduct::
    SupportedProduct (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      majorVersion_ (this),
      name_ (this),
      displayName_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SupportedProduct::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // majorVersion
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "majorVersion",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< MajorVersionType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< MajorVersionType > r (
              dynamic_cast< MajorVersionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->majorVersion_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "displayName" && n.namespace_ ().empty ())
        {
          this->displayName_.set (DisplayNameTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!displayName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "displayName",
          "");
      }
    }

    SupportedProduct* SupportedProduct::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SupportedProduct (*this, f, c);
    }

    SupportedProduct& SupportedProduct::
    operator= (const SupportedProduct& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->majorVersion_ = x.majorVersion_;
        this->name_ = x.name_;
        this->displayName_ = x.displayName_;
      }

      return *this;
    }

    SupportedProduct::
    ~SupportedProduct ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportedProduct >
    _xsd_SupportedProduct_type_factory_init (
      "SupportedProduct",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // SupportedMajorVersion
    //

    SupportedMajorVersion::
    SupportedMajorVersion (const NameType& name,
                           const DisplayNameType& displayName,
                           const VersionIndexType& versionIndex)
    : ::xml_schema::Type (),
      minorVersion_ (this),
      name_ (name, this),
      displayName_ (displayName, this),
      versionIndex_ (versionIndex, this)
    {
    }

    SupportedMajorVersion::
    SupportedMajorVersion (const SupportedMajorVersion& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      minorVersion_ (x.minorVersion_, f, this),
      name_ (x.name_, f, this),
      displayName_ (x.displayName_, f, this),
      versionIndex_ (x.versionIndex_, f, this)
    {
    }

    SupportedMajorVersion::
    SupportedMajorVersion (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      minorVersion_ (this),
      name_ (this),
      displayName_ (this),
      versionIndex_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SupportedMajorVersion::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // minorVersion
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "minorVersion",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< MinorVersionType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< MinorVersionType > r (
              dynamic_cast< MinorVersionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->minorVersion_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "displayName" && n.namespace_ ().empty ())
        {
          this->displayName_.set (DisplayNameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "versionIndex" && n.namespace_ ().empty ())
        {
          this->versionIndex_.set (VersionIndexTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!displayName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "displayName",
          "");
      }

      if (!versionIndex_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "versionIndex",
          "");
      }
    }

    SupportedMajorVersion* SupportedMajorVersion::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SupportedMajorVersion (*this, f, c);
    }

    SupportedMajorVersion& SupportedMajorVersion::
    operator= (const SupportedMajorVersion& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->minorVersion_ = x.minorVersion_;
        this->name_ = x.name_;
        this->displayName_ = x.displayName_;
        this->versionIndex_ = x.versionIndex_;
      }

      return *this;
    }

    SupportedMajorVersion::
    ~SupportedMajorVersion ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportedMajorVersion >
    _xsd_SupportedMajorVersion_type_factory_init (
      "SupportedMajorVersion",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // SupportedMinorVersion
    //

    SupportedMinorVersion::
    SupportedMinorVersion (const DisplayNameType& displayName,
                           const NameType& name,
                           const VersionIndexType& versionIndex)
    : ::xml_schema::Type (),
      displayName_ (displayName, this),
      name_ (name, this),
      versionIndex_ (versionIndex, this)
    {
    }

    SupportedMinorVersion::
    SupportedMinorVersion (const SupportedMinorVersion& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      displayName_ (x.displayName_, f, this),
      name_ (x.name_, f, this),
      versionIndex_ (x.versionIndex_, f, this)
    {
    }

    SupportedMinorVersion::
    SupportedMinorVersion (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      displayName_ (this),
      name_ (this),
      versionIndex_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SupportedMinorVersion::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "displayName" && n.namespace_ ().empty ())
        {
          this->displayName_.set (DisplayNameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "versionIndex" && n.namespace_ ().empty ())
        {
          this->versionIndex_.set (VersionIndexTraits::create (i, f, this));
          continue;
        }
      }

      if (!displayName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "displayName",
          "");
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!versionIndex_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "versionIndex",
          "");
      }
    }

    SupportedMinorVersion* SupportedMinorVersion::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SupportedMinorVersion (*this, f, c);
    }

    SupportedMinorVersion& SupportedMinorVersion::
    operator= (const SupportedMinorVersion& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->displayName_ = x.displayName_;
        this->name_ = x.name_;
        this->versionIndex_ = x.versionIndex_;
      }

      return *this;
    }

    SupportedMinorVersion::
    ~SupportedMinorVersion ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportedMinorVersion >
    _xsd_SupportedMinorVersion_type_factory_init (
      "SupportedMinorVersion",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // SupportedOnReference
    //

    SupportedOnReference::
    SupportedOnReference (const RefType& ref)
    : ::xml_schema::Type (),
      ref_ (ref, this)
    {
    }

    SupportedOnReference::
    SupportedOnReference (const SupportedOnReference& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ref_ (x.ref_, f, this)
    {
    }

    SupportedOnReference::
    SupportedOnReference (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ref_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SupportedOnReference::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ref" && n.namespace_ ().empty ())
        {
          this->ref_.set (RefTraits::create (i, f, this));
          continue;
        }
      }

      if (!ref_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ref",
          "");
      }
    }

    SupportedOnReference* SupportedOnReference::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SupportedOnReference (*this, f, c);
    }

    SupportedOnReference& SupportedOnReference::
    operator= (const SupportedOnReference& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->ref_ = x.ref_;
      }

      return *this;
    }

    SupportedOnReference::
    ~SupportedOnReference ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportedOnReference >
    _xsd_SupportedOnReference_type_factory_init (
      "SupportedOnReference",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // SupportedOnRange
    //

    SupportedOnRange::
    SupportedOnRange (const RefType& ref)
    : ::xml_schema::Type (),
      ref_ (ref, this),
      minVersionIndex_ (this),
      maxVersionIndex_ (this)
    {
    }

    SupportedOnRange::
    SupportedOnRange (const SupportedOnRange& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      ref_ (x.ref_, f, this),
      minVersionIndex_ (x.minVersionIndex_, f, this),
      maxVersionIndex_ (x.maxVersionIndex_, f, this)
    {
    }

    SupportedOnRange::
    SupportedOnRange (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      ref_ (this),
      minVersionIndex_ (this),
      maxVersionIndex_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void SupportedOnRange::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "ref" && n.namespace_ ().empty ())
        {
          this->ref_.set (RefTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "minVersionIndex" && n.namespace_ ().empty ())
        {
          this->minVersionIndex_.set (MinVersionIndexTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "maxVersionIndex" && n.namespace_ ().empty ())
        {
          this->maxVersionIndex_.set (MaxVersionIndexTraits::create (i, f, this));
          continue;
        }
      }

      if (!ref_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "ref",
          "");
      }
    }

    SupportedOnRange* SupportedOnRange::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SupportedOnRange (*this, f, c);
    }

    SupportedOnRange& SupportedOnRange::
    operator= (const SupportedOnRange& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->ref_ = x.ref_;
        this->minVersionIndex_ = x.minVersionIndex_;
        this->maxVersionIndex_ = x.maxVersionIndex_;
      }

      return *this;
    }

    SupportedOnRange::
    ~SupportedOnRange ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportedOnRange >
    _xsd_SupportedOnRange_type_factory_init (
      "SupportedOnRange",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // SupportedAndCondition
    //

    SupportedAndCondition::
    SupportedAndCondition ()
    : ::xml_schema::Type (),
      range_ (this),
      reference_ (this)
    {
    }

    SupportedAndCondition::
    SupportedAndCondition (const SupportedAndCondition& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      range_ (x.range_, f, this),
      reference_ (x.reference_, f, this)
    {
    }

    SupportedAndCondition::
    SupportedAndCondition (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      range_ (this),
      reference_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SupportedAndCondition::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // range
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "range",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< RangeType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< RangeType > r (
              dynamic_cast< RangeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->range_.push_back (::std::move (r));
            continue;
          }
        }

        // reference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "reference",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ReferenceType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ReferenceType > r (
              dynamic_cast< ReferenceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->reference_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SupportedAndCondition* SupportedAndCondition::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SupportedAndCondition (*this, f, c);
    }

    SupportedAndCondition& SupportedAndCondition::
    operator= (const SupportedAndCondition& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->range_ = x.range_;
        this->reference_ = x.reference_;
      }

      return *this;
    }

    SupportedAndCondition::
    ~SupportedAndCondition ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportedAndCondition >
    _xsd_SupportedAndCondition_type_factory_init (
      "SupportedAndCondition",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // SupportedOrCondition
    //

    SupportedOrCondition::
    SupportedOrCondition ()
    : ::xml_schema::Type (),
      range_ (this),
      reference_ (this)
    {
    }

    SupportedOrCondition::
    SupportedOrCondition (const SupportedOrCondition& x,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      range_ (x.range_, f, this),
      reference_ (x.reference_, f, this)
    {
    }

    SupportedOrCondition::
    SupportedOrCondition (const ::xercesc::DOMElement& e,
                          ::xml_schema::Flags f,
                          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      range_ (this),
      reference_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SupportedOrCondition::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // range
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "range",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< RangeType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< RangeType > r (
              dynamic_cast< RangeType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->range_.push_back (::std::move (r));
            continue;
          }
        }

        // reference
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "reference",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ReferenceType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ReferenceType > r (
              dynamic_cast< ReferenceType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->reference_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SupportedOrCondition* SupportedOrCondition::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SupportedOrCondition (*this, f, c);
    }

    SupportedOrCondition& SupportedOrCondition::
    operator= (const SupportedOrCondition& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->range_ = x.range_;
        this->reference_ = x.reference_;
      }

      return *this;
    }

    SupportedOrCondition::
    ~SupportedOrCondition ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportedOrCondition >
    _xsd_SupportedOrCondition_type_factory_init (
      "SupportedOrCondition",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // SupportedOnDefinition
    //

    SupportedOnDefinition::
    SupportedOnDefinition (const NameType& name,
                           const DisplayNameType& displayName)
    : ::xml_schema::Type (),
      or__ (this),
      and__ (this),
      name_ (name, this),
      displayName_ (displayName, this)
    {
    }

    SupportedOnDefinition::
    SupportedOnDefinition (const SupportedOnDefinition& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      or__ (x.or__, f, this),
      and__ (x.and__, f, this),
      name_ (x.name_, f, this),
      displayName_ (x.displayName_, f, this)
    {
    }

    SupportedOnDefinition::
    SupportedOnDefinition (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      or__ (this),
      and__ (this),
      name_ (this),
      displayName_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void SupportedOnDefinition::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // or
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "or",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< OrType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->or__)
            {
              ::std::unique_ptr< OrType > r (
                dynamic_cast< OrType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->or__.set (::std::move (r));
              continue;
            }
          }
        }

        // and
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "and",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< AndType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->and__)
            {
              ::std::unique_ptr< AndType > r (
                dynamic_cast< AndType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->and__.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "displayName" && n.namespace_ ().empty ())
        {
          this->displayName_.set (DisplayNameTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!displayName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "displayName",
          "");
      }
    }

    SupportedOnDefinition* SupportedOnDefinition::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SupportedOnDefinition (*this, f, c);
    }

    SupportedOnDefinition& SupportedOnDefinition::
    operator= (const SupportedOnDefinition& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->or__ = x.or__;
        this->and__ = x.and__;
        this->name_ = x.name_;
        this->displayName_ = x.displayName_;
      }

      return *this;
    }

    SupportedOnDefinition::
    ~SupportedOnDefinition ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportedOnDefinition >
    _xsd_SupportedOnDefinition_type_factory_init (
      "SupportedOnDefinition",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // SupportedOnDefinitions
    //

    SupportedOnDefinitions::
    SupportedOnDefinitions ()
    : ::xml_schema::Type (),
      definition_ (this)
    {
    }

    SupportedOnDefinitions::
    SupportedOnDefinitions (const SupportedOnDefinitions& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      definition_ (x.definition_, f, this)
    {
    }

    SupportedOnDefinitions::
    SupportedOnDefinitions (const ::xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      definition_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void SupportedOnDefinitions::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // definition
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "definition",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< DefinitionType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< DefinitionType > r (
              dynamic_cast< DefinitionType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->definition_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    SupportedOnDefinitions* SupportedOnDefinitions::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class SupportedOnDefinitions (*this, f, c);
    }

    SupportedOnDefinitions& SupportedOnDefinitions::
    operator= (const SupportedOnDefinitions& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->definition_ = x.definition_;
      }

      return *this;
    }

    SupportedOnDefinitions::
    ~SupportedOnDefinitions ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, SupportedOnDefinitions >
    _xsd_SupportedOnDefinitions_type_factory_init (
      "SupportedOnDefinitions",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // PolicyClass
    //

    PolicyClass::
    PolicyClass (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Token (e, f, c)
    {
      _xsd_PolicyClass_convert ();
    }

    PolicyClass::
    PolicyClass (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Token (a, f, c)
    {
      _xsd_PolicyClass_convert ();
    }

    PolicyClass::
    PolicyClass (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Token (s, e, f, c)
    {
      _xsd_PolicyClass_convert ();
    }

    PolicyClass* PolicyClass::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PolicyClass (*this, f, c);
    }

    PolicyClass::Value PolicyClass::
    _xsd_PolicyClass_convert () const
    {
      ::xsd::cxx::tree::enum_comparator< char > c (_xsd_PolicyClass_literals_);
      const Value* i (::std::lower_bound (
                        _xsd_PolicyClass_indexes_,
                        _xsd_PolicyClass_indexes_ + 3,
                        *this,
                        c));

      if (i == _xsd_PolicyClass_indexes_ + 3 || _xsd_PolicyClass_literals_[*i] != *this)
      {
        throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
      }

      return *i;
    }

    const char* const PolicyClass::
    _xsd_PolicyClass_literals_[3] =
    {
      "User",
      "Machine",
      "Both"
    };

    const PolicyClass::Value PolicyClass::
    _xsd_PolicyClass_indexes_[3] =
    {
      ::GroupPolicy::PolicyDefinitions::PolicyClass::Both,
      ::GroupPolicy::PolicyDefinitions::PolicyClass::Machine,
      ::GroupPolicy::PolicyDefinitions::PolicyClass::User
    };

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PolicyClass >
    _xsd_PolicyClass_type_factory_init (
      "PolicyClass",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // PolicyDefinition
    //

    PolicyDefinition::
    PolicyDefinition (const SupportedOnType& supportedOn,
                      const NameType& name,
                      const ClassType& class_,
                      const DisplayNameType& displayName,
                      const KeyType& key)
    : ::xml_schema::Type (),
      annotation_ (this),
      parentCategory_ (this),
      seeAlso_ (this),
      keywords_ (this),
      supportedOn_ (supportedOn, this),
      enabledValue_ (this),
      disabledValue_ (this),
      enabledList_ (this),
      disabledList_ (this),
      elements_ (this),
      name_ (name, this),
      class__ (class_, this),
      displayName_ (displayName, this),
      explainText_ (this),
      presentation_ (this),
      key_ (key, this),
      valueName_ (this)
    {
    }

    PolicyDefinition::
    PolicyDefinition (::std::unique_ptr< SupportedOnType > supportedOn,
                      const NameType& name,
                      const ClassType& class_,
                      const DisplayNameType& displayName,
                      const KeyType& key)
    : ::xml_schema::Type (),
      annotation_ (this),
      parentCategory_ (this),
      seeAlso_ (this),
      keywords_ (this),
      supportedOn_ (std::move (supportedOn), this),
      enabledValue_ (this),
      disabledValue_ (this),
      enabledList_ (this),
      disabledList_ (this),
      elements_ (this),
      name_ (name, this),
      class__ (class_, this),
      displayName_ (displayName, this),
      explainText_ (this),
      presentation_ (this),
      key_ (key, this),
      valueName_ (this)
    {
    }

    PolicyDefinition::
    PolicyDefinition (const PolicyDefinition& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      annotation_ (x.annotation_, f, this),
      parentCategory_ (x.parentCategory_, f, this),
      seeAlso_ (x.seeAlso_, f, this),
      keywords_ (x.keywords_, f, this),
      supportedOn_ (x.supportedOn_, f, this),
      enabledValue_ (x.enabledValue_, f, this),
      disabledValue_ (x.disabledValue_, f, this),
      enabledList_ (x.enabledList_, f, this),
      disabledList_ (x.disabledList_, f, this),
      elements_ (x.elements_, f, this),
      name_ (x.name_, f, this),
      class__ (x.class__, f, this),
      displayName_ (x.displayName_, f, this),
      explainText_ (x.explainText_, f, this),
      presentation_ (x.presentation_, f, this),
      key_ (x.key_, f, this),
      valueName_ (x.valueName_, f, this)
    {
    }

    PolicyDefinition::
    PolicyDefinition (const ::xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      annotation_ (this),
      parentCategory_ (this),
      seeAlso_ (this),
      keywords_ (this),
      supportedOn_ (this),
      enabledValue_ (this),
      disabledValue_ (this),
      enabledList_ (this),
      disabledList_ (this),
      elements_ (this),
      name_ (this),
      class__ (this),
      displayName_ (this),
      explainText_ (this),
      presentation_ (this),
      key_ (this),
      valueName_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void PolicyDefinition::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // annotation
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "annotation",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< AnnotationType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< AnnotationType > r (
              dynamic_cast< AnnotationType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->annotation_.push_back (::std::move (r));
            continue;
          }
        }

        // parentCategory
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "parentCategory",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ParentCategoryType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->parentCategory_)
            {
              ::std::unique_ptr< ParentCategoryType > r (
                dynamic_cast< ParentCategoryType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->parentCategory_.set (::std::move (r));
              continue;
            }
          }
        }

        // seeAlso
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "seeAlso",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< SeeAlsoType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< SeeAlsoType > r (
              dynamic_cast< SeeAlsoType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->seeAlso_.push_back (::std::move (r));
            continue;
          }
        }

        // keywords
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "keywords",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< KeywordsType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->keywords_)
            {
              ::std::unique_ptr< KeywordsType > r (
                dynamic_cast< KeywordsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->keywords_.set (::std::move (r));
              continue;
            }
          }
        }

        // supportedOn
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "supportedOn",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< SupportedOnType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!supportedOn_.present ())
            {
              ::std::unique_ptr< SupportedOnType > r (
                dynamic_cast< SupportedOnType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->supportedOn_.set (::std::move (r));
              continue;
            }
          }
        }

        // enabledValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "enabledValue",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< EnabledValueType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->enabledValue_)
            {
              ::std::unique_ptr< EnabledValueType > r (
                dynamic_cast< EnabledValueType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->enabledValue_.set (::std::move (r));
              continue;
            }
          }
        }

        // disabledValue
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "disabledValue",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< DisabledValueType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->disabledValue_)
            {
              ::std::unique_ptr< DisabledValueType > r (
                dynamic_cast< DisabledValueType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->disabledValue_.set (::std::move (r));
              continue;
            }
          }
        }

        // enabledList
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "enabledList",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< EnabledListType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->enabledList_)
            {
              ::std::unique_ptr< EnabledListType > r (
                dynamic_cast< EnabledListType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->enabledList_.set (::std::move (r));
              continue;
            }
          }
        }

        // disabledList
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "disabledList",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< DisabledListType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->disabledList_)
            {
              ::std::unique_ptr< DisabledListType > r (
                dynamic_cast< DisabledListType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->disabledList_.set (::std::move (r));
              continue;
            }
          }
        }

        // elements
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "elements",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ElementsType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->elements_)
            {
              ::std::unique_ptr< ElementsType > r (
                dynamic_cast< ElementsType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->elements_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!supportedOn_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "supportedOn",
          "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "name" && n.namespace_ ().empty ())
        {
          this->name_.set (NameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "class" && n.namespace_ ().empty ())
        {
          this->class__.set (ClassTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "displayName" && n.namespace_ ().empty ())
        {
          this->displayName_.set (DisplayNameTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "explainText" && n.namespace_ ().empty ())
        {
          this->explainText_.set (ExplainTextTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "presentation" && n.namespace_ ().empty ())
        {
          this->presentation_.set (PresentationTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "key" && n.namespace_ ().empty ())
        {
          this->key_.set (KeyTraits::create (i, f, this));
          continue;
        }

        if (n.name () == "valueName" && n.namespace_ ().empty ())
        {
          this->valueName_.set (ValueNameTraits::create (i, f, this));
          continue;
        }
      }

      if (!name_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "name",
          "");
      }

      if (!class__.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "class",
          "");
      }

      if (!displayName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "displayName",
          "");
      }

      if (!key_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "key",
          "");
      }
    }

    PolicyDefinition* PolicyDefinition::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PolicyDefinition (*this, f, c);
    }

    PolicyDefinition& PolicyDefinition::
    operator= (const PolicyDefinition& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->annotation_ = x.annotation_;
        this->parentCategory_ = x.parentCategory_;
        this->seeAlso_ = x.seeAlso_;
        this->keywords_ = x.keywords_;
        this->supportedOn_ = x.supportedOn_;
        this->enabledValue_ = x.enabledValue_;
        this->disabledValue_ = x.disabledValue_;
        this->enabledList_ = x.enabledList_;
        this->disabledList_ = x.disabledList_;
        this->elements_ = x.elements_;
        this->name_ = x.name_;
        this->class__ = x.class__;
        this->displayName_ = x.displayName_;
        this->explainText_ = x.explainText_;
        this->presentation_ = x.presentation_;
        this->key_ = x.key_;
        this->valueName_ = x.valueName_;
      }

      return *this;
    }

    PolicyDefinition::
    ~PolicyDefinition ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PolicyDefinition >
    _xsd_PolicyDefinition_type_factory_init (
      "PolicyDefinition",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // PolicyElements
    //

    PolicyElements::
    PolicyElements ()
    : ::xml_schema::Type (),
      boolean_ (this),
      decimal_ (this),
      text_ (this),
      enum__ (this),
      list_ (this),
      longDecimal_ (this),
      multiText_ (this)
    {
    }

    PolicyElements::
    PolicyElements (const PolicyElements& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      boolean_ (x.boolean_, f, this),
      decimal_ (x.decimal_, f, this),
      text_ (x.text_, f, this),
      enum__ (x.enum__, f, this),
      list_ (x.list_, f, this),
      longDecimal_ (x.longDecimal_, f, this),
      multiText_ (x.multiText_, f, this)
    {
    }

    PolicyElements::
    PolicyElements (const ::xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      boolean_ (this),
      decimal_ (this),
      text_ (this),
      enum__ (this),
      list_ (this),
      longDecimal_ (this),
      multiText_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void PolicyElements::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // boolean
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "boolean",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< BooleanType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< BooleanType > r (
              dynamic_cast< BooleanType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->boolean_.push_back (::std::move (r));
            continue;
          }
        }

        // decimal
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "decimal",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< DecimalType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< DecimalType > r (
              dynamic_cast< DecimalType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->decimal_.push_back (::std::move (r));
            continue;
          }
        }

        // text
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "text",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< TextType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< TextType > r (
              dynamic_cast< TextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->text_.push_back (::std::move (r));
            continue;
          }
        }

        // enum
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "enum",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< EnumType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< EnumType > r (
              dynamic_cast< EnumType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->enum__.push_back (::std::move (r));
            continue;
          }
        }

        // list
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "list",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ListType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< ListType > r (
              dynamic_cast< ListType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->list_.push_back (::std::move (r));
            continue;
          }
        }

        // longDecimal
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "longDecimal",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< LongDecimalType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< LongDecimalType > r (
              dynamic_cast< LongDecimalType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->longDecimal_.push_back (::std::move (r));
            continue;
          }
        }

        // multiText
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "multiText",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< MultiTextType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::unique_ptr< MultiTextType > r (
              dynamic_cast< MultiTextType* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->multiText_.push_back (::std::move (r));
            continue;
          }
        }

        break;
      }
    }

    PolicyElements* PolicyElements::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PolicyElements (*this, f, c);
    }

    PolicyElements& PolicyElements::
    operator= (const PolicyElements& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->boolean_ = x.boolean_;
        this->decimal_ = x.decimal_;
        this->text_ = x.text_;
        this->enum__ = x.enum__;
        this->list_ = x.list_;
        this->longDecimal_ = x.longDecimal_;
        this->multiText_ = x.multiText_;
      }

      return *this;
    }

    PolicyElements::
    ~PolicyElements ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PolicyElements >
    _xsd_PolicyElements_type_factory_init (
      "PolicyElements",
      "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");

    // Item
    //

    Item::
    Item (const ValueType& value,
          const DisplayNameType& displayName)
    : ::xml_schema::Type (),
      value_ (value, this),
      valueList_ (this),
      displayName_ (displayName, this)
    {
    }

    Item::
    Item (::std::unique_ptr< ValueType > value,
          const DisplayNameType& displayName)
    : ::xml_schema::Type (),
      value_ (std::move (value), this),
      valueList_ (this),
      displayName_ (displayName, this)
    {
    }

    Item::
    Item (const Item& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      value_ (x.value_, f, this),
      valueList_ (x.valueList_, f, this),
      displayName_ (x.displayName_, f, this)
    {
    }

    Item::
    Item (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      value_ (this),
      valueList_ (this),
      displayName_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Item::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // value
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "value",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ValueType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!value_.present ())
            {
              ::std::unique_ptr< ValueType > r (
                dynamic_cast< ValueType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->value_.set (::std::move (r));
              continue;
            }
          }
        }

        // valueList
        //
        {
          ::std::unique_ptr< ::xsd::cxx::tree::type > tmp (
            ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
              "valueList",
              "http://www.microsoft.com/GroupPolicy/PolicyDefinitions",
              &::xsd::cxx::tree::factory_impl< ValueListType >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->valueList_)
            {
              ::std::unique_ptr< ValueListType > r (
                dynamic_cast< ValueListType* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< char > ();

              this->valueList_.set (::std::move (r));
              continue;
            }
          }
        }

        break;
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "value",
          "http://www.microsoft.com/GroupPolicy/PolicyDefinitions");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "displayName" && n.namespace_ ().empty ())
        {
          this->displayName_.set (DisplayNameTraits::create (i, f, this));
          continue;
        }
      }

      if (!displayName_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "displayName",
          "");
      }
    }

    Item* Item::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Item (*this, f, c);
    }

    Item& Item::
    operator= (const Item& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->value_ = x.value_;
        this->valueList_ = x.valueList_;
        this->displayName_ = x.displayName_;
      }

      return *this;
    }

    Item::
    ~Item ()
    {
    }

    // Delete
    //

    Delete::
    Delete ()
    : ::xml_schema::Type ()
    {
    }

    Delete::
    Delete (const Delete& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c)
    {
    }

    Delete::
    Delete (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f, c)
    {
    }

    Delete::
    Delete (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (a, f, c)
    {
    }

    Delete::
    Delete (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::Type (s, e, f, c)
    {
    }

    Delete* Delete::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Delete (*this, f, c);
    }

    Delete::
    ~Delete ()
    {
    }

    // Decimal
    //

    Decimal::
    Decimal (const ValueType& value)
    : ::xml_schema::Type (),
      value_ (value, this)
    {
    }

    Decimal::
    Decimal (const Decimal& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    Decimal::
    Decimal (const ::xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void Decimal::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    Decimal* Decimal::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Decimal (*this, f, c);
    }

    Decimal& Decimal::
    operator= (const Decimal& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    Decimal::
    ~Decimal ()
    {
    }

    // LongDecimal
    //

    LongDecimal::
    LongDecimal (const ValueType& value)
    : ::xml_schema::Type (),
      value_ (value, this)
    {
    }

    LongDecimal::
    LongDecimal (const LongDecimal& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      value_ (x.value_, f, this)
    {
    }

    LongDecimal::
    LongDecimal (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      value_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void LongDecimal::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "value" && n.namespace_ ().empty ())
        {
          this->value_.set (ValueTraits::create (i, f, this));
          continue;
        }
      }

      if (!value_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "value",
          "");
      }
    }

    LongDecimal* LongDecimal::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class LongDecimal (*this, f, c);
    }

    LongDecimal& LongDecimal::
    operator= (const LongDecimal& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->value_ = x.value_;
      }

      return *this;
    }

    LongDecimal::
    ~LongDecimal ()
    {
    }

    // String
    //

    String::
    String ()
    : ::xml_schema::String ()
    {
    }

    String::
    String (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    String::
    String (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    String::
    String (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    String::
    String (const String& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    String::
    String (const ::xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    String::
    String (const ::xercesc::DOMAttr& a,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    String::
    String (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    String* String::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class String (*this, f, c);
    }

    String::
    ~String ()
    {
    }
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
    ::std::ostream&
    operator<< (::std::ostream& o, const DecimalElement& i)
    {
      o << ::std::endl << "id: " << i.id ();
      if (i.clientExtension ())
      {
        o << ::std::endl << "clientExtension: " << *i.clientExtension ();
      }

      if (i.key ())
      {
        o << ::std::endl << "key: " << *i.key ();
      }

      if (i.valueName ())
      {
        o << ::std::endl << "valueName: " << *i.valueName ();
      }

      o << ::std::endl << "required: " << i.required ();
      o << ::std::endl << "minValue: " << i.minValue ();
      o << ::std::endl << "maxValue: " << i.maxValue ();
      o << ::std::endl << "storeAsText: " << i.storeAsText ();
      o << ::std::endl << "soft: " << i.soft ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, DecimalElement >
    _xsd_DecimalElement_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const LongDecimalElement& i)
    {
      o << ::std::endl << "id: " << i.id ();
      if (i.clientExtension ())
      {
        o << ::std::endl << "clientExtension: " << *i.clientExtension ();
      }

      if (i.key ())
      {
        o << ::std::endl << "key: " << *i.key ();
      }

      if (i.valueName ())
      {
        o << ::std::endl << "valueName: " << *i.valueName ();
      }

      o << ::std::endl << "required: " << i.required ();
      o << ::std::endl << "minValue: " << i.minValue ();
      o << ::std::endl << "maxValue: " << i.maxValue ();
      o << ::std::endl << "storeAsText: " << i.storeAsText ();
      o << ::std::endl << "soft: " << i.soft ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, LongDecimalElement >
    _xsd_LongDecimalElement_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const BooleanElement& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.trueValue ())
        {
          o << ::std::endl << "trueValue: ";
          om.insert (o, *i.trueValue ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.falseValue ())
        {
          o << ::std::endl << "falseValue: ";
          om.insert (o, *i.falseValue ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.trueList ())
        {
          o << ::std::endl << "trueList: ";
          om.insert (o, *i.trueList ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.falseList ())
        {
          o << ::std::endl << "falseList: ";
          om.insert (o, *i.falseList ());
        }
      }

      o << ::std::endl << "id: " << i.id ();
      if (i.clientExtension ())
      {
        o << ::std::endl << "clientExtension: " << *i.clientExtension ();
      }

      if (i.key ())
      {
        o << ::std::endl << "key: " << *i.key ();
      }

      if (i.valueName ())
      {
        o << ::std::endl << "valueName: " << *i.valueName ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, BooleanElement >
    _xsd_BooleanElement_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const TextElement& i)
    {
      o << ::std::endl << "id: " << i.id ();
      if (i.clientExtension ())
      {
        o << ::std::endl << "clientExtension: " << *i.clientExtension ();
      }

      if (i.key ())
      {
        o << ::std::endl << "key: " << *i.key ();
      }

      if (i.valueName ())
      {
        o << ::std::endl << "valueName: " << *i.valueName ();
      }

      o << ::std::endl << "required: " << i.required ();
      o << ::std::endl << "maxLength: " << i.maxLength ();
      o << ::std::endl << "expandable: " << i.expandable ();
      o << ::std::endl << "soft: " << i.soft ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, TextElement >
    _xsd_TextElement_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const EnumerationElement& i)
    {
      for (EnumerationElement::ItemConstIterator
           b (i.item ().begin ()), e (i.item ().end ());
           b != e; ++b)
      {
        o << ::std::endl << "item: " << *b;
      }

      o << ::std::endl << "id: " << i.id ();
      if (i.clientExtension ())
      {
        o << ::std::endl << "clientExtension: " << *i.clientExtension ();
      }

      if (i.key ())
      {
        o << ::std::endl << "key: " << *i.key ();
      }

      if (i.valueName ())
      {
        o << ::std::endl << "valueName: " << *i.valueName ();
      }

      o << ::std::endl << "required: " << i.required ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, EnumerationElement >
    _xsd_EnumerationElement_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const ListElement& i)
    {
      o << ::std::endl << "id: " << i.id ();
      if (i.clientExtension ())
      {
        o << ::std::endl << "clientExtension: " << *i.clientExtension ();
      }

      if (i.key ())
      {
        o << ::std::endl << "key: " << *i.key ();
      }

      if (i.valuePrefix ())
      {
        o << ::std::endl << "valuePrefix: " << *i.valuePrefix ();
      }

      o << ::std::endl << "additive: " << i.additive ();
      o << ::std::endl << "expandable: " << i.expandable ();
      o << ::std::endl << "explicitValue: " << i.explicitValue ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ListElement >
    _xsd_ListElement_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const Value& i)
    {
      if (i.delete_ ())
      {
        o << ::std::endl << "delete: " << *i.delete_ ();
      }

      if (i.decimal ())
      {
        o << ::std::endl << "decimal: " << *i.decimal ();
      }

      if (i.longDecimal ())
      {
        o << ::std::endl << "longDecimal: " << *i.longDecimal ();
      }

      if (i.string ())
      {
        o << ::std::endl << "string: " << *i.string ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, Value >
    _xsd_Value_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const ValueList& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (ValueList::ItemConstIterator
             b (i.item ().begin ()), e (i.item ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "item: ";
          om.insert (o, *b);
        }
      }

      if (i.defaultKey ())
      {
        o << ::std::endl << "defaultKey: " << *i.defaultKey ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ValueList >
    _xsd_ValueList_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const ValueItem& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "value: ";
        om.insert (o, i.value ());
      }

      if (i.key ())
      {
        o << ::std::endl << "key: " << *i.key ();
      }

      o << ::std::endl << "valueName: " << i.valueName ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ValueItem >
    _xsd_ValueItem_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const MultiTextElement& i)
    {
      o << ::std::endl << "id: " << i.id ();
      if (i.clientExtension ())
      {
        o << ::std::endl << "clientExtension: " << *i.clientExtension ();
      }

      if (i.key ())
      {
        o << ::std::endl << "key: " << *i.key ();
      }

      if (i.valueName ())
      {
        o << ::std::endl << "valueName: " << *i.valueName ();
      }

      o << ::std::endl << "required: " << i.required ();
      o << ::std::endl << "maxLength: " << i.maxLength ();
      o << ::std::endl << "maxStrings: " << i.maxStrings ();
      o << ::std::endl << "soft: " << i.soft ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, MultiTextElement >
    _xsd_MultiTextElement_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const DataElementContent& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      o << ::std::endl << "refId: " << i.refId ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const DataElement& i)
    {
      o << ::std::endl << "refId: " << i.refId ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const DecimalTextBox& i)
    {
      o << static_cast< const ::GroupPolicy::PolicyDefinitions::DataElementContent& > (i);

      o << ::std::endl << "defaultValue: " << i.defaultValue ();
      o << ::std::endl << "spin: " << i.spin ();
      o << ::std::endl << "spinStep: " << i.spinStep ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, DecimalTextBox >
    _xsd_DecimalTextBox_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const LongDecimalTextBox& i)
    {
      o << static_cast< const ::GroupPolicy::PolicyDefinitions::DataElementContent& > (i);

      o << ::std::endl << "defaultValue: " << i.defaultValue ();
      o << ::std::endl << "spin: " << i.spin ();
      o << ::std::endl << "spinStep: " << i.spinStep ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, LongDecimalTextBox >
    _xsd_LongDecimalTextBox_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const TextBox& i)
    {
      o << static_cast< const ::GroupPolicy::PolicyDefinitions::DataElement& > (i);

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "label: ";
        om.insert (o, i.label ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.defaultValue ())
        {
          o << ::std::endl << "defaultValue: ";
          om.insert (o, *i.defaultValue ());
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, TextBox >
    _xsd_TextBox_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const MultiTextBox& i)
    {
      o << static_cast< const ::GroupPolicy::PolicyDefinitions::DataElement& > (i);

      o << ::std::endl << "showAsDialog: " << i.showAsDialog ();
      o << ::std::endl << "defaultHeight: " << i.defaultHeight ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, MultiTextBox >
    _xsd_MultiTextBox_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const CheckBox& i)
    {
      o << static_cast< const ::GroupPolicy::PolicyDefinitions::DataElementContent& > (i);

      o << ::std::endl << "defaultChecked: " << i.defaultChecked ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CheckBox >
    _xsd_CheckBox_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const ComboBox& i)
    {
      o << static_cast< const ::GroupPolicy::PolicyDefinitions::DataElement& > (i);

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "label: ";
        om.insert (o, i.label ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.default_ ())
        {
          o << ::std::endl << "default: ";
          om.insert (o, *i.default_ ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (ComboBox::SuggestionConstIterator
             b (i.suggestion ().begin ()), e (i.suggestion ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "suggestion: ";
          om.insert (o, *b);
        }
      }

      o << ::std::endl << "noSort: " << i.noSort ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ComboBox >
    _xsd_ComboBox_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const DropdownList& i)
    {
      o << static_cast< const ::GroupPolicy::PolicyDefinitions::DataElementContent& > (i);

      o << ::std::endl << "noSort: " << i.noSort ();
      if (i.defaultItem ())
      {
        o << ::std::endl << "defaultItem: " << *i.defaultItem ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, DropdownList >
    _xsd_DropdownList_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const ListBox& i)
    {
      o << static_cast< const ::GroupPolicy::PolicyDefinitions::DataElementContent& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ListBox >
    _xsd_ListBox_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const PolicyPresentation& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyPresentation::TextConstIterator
             b (i.text ().begin ()), e (i.text ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "text: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyPresentation::DecimalTextBoxConstIterator
             b (i.decimalTextBox ().begin ()), e (i.decimalTextBox ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "decimalTextBox: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyPresentation::TextBoxConstIterator
             b (i.textBox ().begin ()), e (i.textBox ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "textBox: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyPresentation::CheckBoxConstIterator
             b (i.checkBox ().begin ()), e (i.checkBox ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "checkBox: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyPresentation::ComboBoxConstIterator
             b (i.comboBox ().begin ()), e (i.comboBox ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "comboBox: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyPresentation::DropdownListConstIterator
             b (i.dropdownList ().begin ()), e (i.dropdownList ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "dropdownList: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyPresentation::ListBoxConstIterator
             b (i.listBox ().begin ()), e (i.listBox ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "listBox: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyPresentation::LongDecimalTextBoxConstIterator
             b (i.longDecimalTextBox ().begin ()), e (i.longDecimalTextBox ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "longDecimalTextBox: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyPresentation::MultiTextBoxConstIterator
             b (i.multiTextBox ().begin ()), e (i.multiTextBox ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "multiTextBox: ";
          om.insert (o, *b);
        }
      }

      o << ::std::endl << "id: " << i.id ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, PolicyPresentation >
    _xsd_PolicyPresentation_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const CategoryReference& i)
    {
      o << ::std::endl << "ref: " << i.ref ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, CategoryReference >
    _xsd_CategoryReference_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const Category& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (Category::AnnotationConstIterator
             b (i.annotation ().begin ()), e (i.annotation ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "annotation: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.parentCategory ())
        {
          o << ::std::endl << "parentCategory: ";
          om.insert (o, *i.parentCategory ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (Category::SeeAlsoConstIterator
             b (i.seeAlso ().begin ()), e (i.seeAlso ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "seeAlso: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.keywords ())
        {
          o << ::std::endl << "keywords: ";
          om.insert (o, *i.keywords ());
        }
      }

      o << ::std::endl << "name: " << i.name ();
      o << ::std::endl << "displayName: " << i.displayName ();
      if (i.explainText ())
      {
        o << ::std::endl << "explainText: " << *i.explainText ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, Category >
    _xsd_Category_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SupportedProducts& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (SupportedProducts::ProductConstIterator
             b (i.product ().begin ()), e (i.product ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "product: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportedProducts >
    _xsd_SupportedProducts_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SupportedProduct& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (SupportedProduct::MajorVersionConstIterator
             b (i.majorVersion ().begin ()), e (i.majorVersion ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "majorVersion: ";
          om.insert (o, *b);
        }
      }

      o << ::std::endl << "name: " << i.name ();
      o << ::std::endl << "displayName: " << i.displayName ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportedProduct >
    _xsd_SupportedProduct_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SupportedMajorVersion& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (SupportedMajorVersion::MinorVersionConstIterator
             b (i.minorVersion ().begin ()), e (i.minorVersion ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "minorVersion: ";
          om.insert (o, *b);
        }
      }

      o << ::std::endl << "name: " << i.name ();
      o << ::std::endl << "displayName: " << i.displayName ();
      o << ::std::endl << "versionIndex: " << i.versionIndex ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportedMajorVersion >
    _xsd_SupportedMajorVersion_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SupportedMinorVersion& i)
    {
      o << ::std::endl << "displayName: " << i.displayName ();
      o << ::std::endl << "name: " << i.name ();
      o << ::std::endl << "versionIndex: " << i.versionIndex ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportedMinorVersion >
    _xsd_SupportedMinorVersion_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SupportedOnReference& i)
    {
      o << ::std::endl << "ref: " << i.ref ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportedOnReference >
    _xsd_SupportedOnReference_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SupportedOnRange& i)
    {
      o << ::std::endl << "ref: " << i.ref ();
      if (i.minVersionIndex ())
      {
        o << ::std::endl << "minVersionIndex: " << *i.minVersionIndex ();
      }

      if (i.maxVersionIndex ())
      {
        o << ::std::endl << "maxVersionIndex: " << *i.maxVersionIndex ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportedOnRange >
    _xsd_SupportedOnRange_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SupportedAndCondition& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (SupportedAndCondition::RangeConstIterator
             b (i.range ().begin ()), e (i.range ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "range: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (SupportedAndCondition::ReferenceConstIterator
             b (i.reference ().begin ()), e (i.reference ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "reference: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportedAndCondition >
    _xsd_SupportedAndCondition_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SupportedOrCondition& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (SupportedOrCondition::RangeConstIterator
             b (i.range ().begin ()), e (i.range ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "range: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (SupportedOrCondition::ReferenceConstIterator
             b (i.reference ().begin ()), e (i.reference ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "reference: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportedOrCondition >
    _xsd_SupportedOrCondition_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SupportedOnDefinition& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.or_ ())
        {
          o << ::std::endl << "or: ";
          om.insert (o, *i.or_ ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.and_ ())
        {
          o << ::std::endl << "and: ";
          om.insert (o, *i.and_ ());
        }
      }

      o << ::std::endl << "name: " << i.name ();
      o << ::std::endl << "displayName: " << i.displayName ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportedOnDefinition >
    _xsd_SupportedOnDefinition_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const SupportedOnDefinitions& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (SupportedOnDefinitions::DefinitionConstIterator
             b (i.definition ().begin ()), e (i.definition ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "definition: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, SupportedOnDefinitions >
    _xsd_SupportedOnDefinitions_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, PolicyClass::Value i)
    {
      return o << PolicyClass::_xsd_PolicyClass_literals_[i];
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const PolicyClass& i)
    {
      return o << static_cast< const ::xml_schema::Token& > (i);
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, PolicyClass >
    _xsd_PolicyClass_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const PolicyDefinition& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyDefinition::AnnotationConstIterator
             b (i.annotation ().begin ()), e (i.annotation ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "annotation: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.parentCategory ())
        {
          o << ::std::endl << "parentCategory: ";
          om.insert (o, *i.parentCategory ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyDefinition::SeeAlsoConstIterator
             b (i.seeAlso ().begin ()), e (i.seeAlso ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "seeAlso: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.keywords ())
        {
          o << ::std::endl << "keywords: ";
          om.insert (o, *i.keywords ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "supportedOn: ";
        om.insert (o, i.supportedOn ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.enabledValue ())
        {
          o << ::std::endl << "enabledValue: ";
          om.insert (o, *i.enabledValue ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.disabledValue ())
        {
          o << ::std::endl << "disabledValue: ";
          om.insert (o, *i.disabledValue ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.enabledList ())
        {
          o << ::std::endl << "enabledList: ";
          om.insert (o, *i.enabledList ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.disabledList ())
        {
          o << ::std::endl << "disabledList: ";
          om.insert (o, *i.disabledList ());
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.elements ())
        {
          o << ::std::endl << "elements: ";
          om.insert (o, *i.elements ());
        }
      }

      o << ::std::endl << "name: " << i.name ();
      o << ::std::endl << "class: " << i.class_ ();
      o << ::std::endl << "displayName: " << i.displayName ();
      if (i.explainText ())
      {
        o << ::std::endl << "explainText: " << *i.explainText ();
      }

      if (i.presentation ())
      {
        o << ::std::endl << "presentation: " << *i.presentation ();
      }

      o << ::std::endl << "key: " << i.key ();
      if (i.valueName ())
      {
        o << ::std::endl << "valueName: " << *i.valueName ();
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, PolicyDefinition >
    _xsd_PolicyDefinition_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const PolicyElements& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyElements::BooleanConstIterator
             b (i.boolean ().begin ()), e (i.boolean ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "boolean: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyElements::DecimalConstIterator
             b (i.decimal ().begin ()), e (i.decimal ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "decimal: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyElements::TextConstIterator
             b (i.text ().begin ()), e (i.text ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "text: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyElements::EnumConstIterator
             b (i.enum_ ().begin ()), e (i.enum_ ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "enum: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyElements::ListConstIterator
             b (i.list ().begin ()), e (i.list ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "list: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyElements::LongDecimalConstIterator
             b (i.longDecimal ().begin ()), e (i.longDecimal ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "longDecimal: ";
          om.insert (o, *b);
        }
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        for (PolicyElements::MultiTextConstIterator
             b (i.multiText ().begin ()), e (i.multiText ().end ());
             b != e; ++b)
        {
          o << ::std::endl << "multiText: ";
          om.insert (o, *b);
        }
      }

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, PolicyElements >
    _xsd_PolicyElements_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const Item& i)
    {
      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        o << ::std::endl << "value: ";
        om.insert (o, i.value ());
      }

      {
        ::xsd::cxx::tree::std_ostream_map< char >& om (
          ::xsd::cxx::tree::std_ostream_map_instance< 0, char > ());

        if (i.valueList ())
        {
          o << ::std::endl << "valueList: ";
          om.insert (o, *i.valueList ());
        }
      }

      o << ::std::endl << "displayName: " << i.displayName ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Delete&)
    {
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const Decimal& i)
    {
      o << ::std::endl << "value: " << i.value ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const LongDecimal& i)
    {
      o << ::std::endl << "value: " << i.value ();
      return o;
    }

    ::std::ostream&
    operator<< (::std::ostream& o, const String& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

